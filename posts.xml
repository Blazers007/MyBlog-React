<?xml version="1.0" encoding="utf-8"?>
<!--
- phpMyAdmin XML Dump
- version 3.4.8
- http://www.phpmyadmin.net
-
- 主机: sqld.duapp.com:4050
- 生成日期: 2016 年 01 月 27 日 14:14
- 服务器版本: 5.5.35
- PHP 版本: 5.2.10
-->

<pma_xml_export version="1.0" xmlns:pma="http://www.phpmyadmin.net/some_doc_url/">
    <database name="LLCNwjzQMvIaNgIbFMvr">
        <!-- 表 posts -->
        <table name="posts">
            <column name="id">1</column>
            <column name="uuid">b2c6701f-cd25-4667-9c14-4f6ca9c78076</column>
            <column name="title">写在开始</column>
            <column name="slug">welcome-to-ghost</column>
            <column name="markdown">
                折腾了周末两天时间，算是把Ghost这个东西部署好了，先后尝试了[BAE](http://developer.baidu.com/cloud/rt)（提示已经欠费）,[JAE](http://appengine.jd.com/product/jae.html)(啥破玩意建立个应用都要卡半年？)以及之前牛人推荐的 [Nitrous.IO](nitrous.io/)（其实这个还好，只是因为被墙的原因国内访问速度有相当大的问题）

                最后，想起来先前用的Cloud 9，就上来尝试了一下。

                ***
                &gt; 项目创建方法

                - 登陆[Cloud9](c9.io/)
                - 注册一个账号
                - 新建一个WorkSpace 指定为 Node
                - 下载最新的[Ghost](http://www.ghostchina.com/download/)
                - 上传全部文件或ZIP压缩包到你的WorkSpace
                - npm install --production
                - 打开config.js文件 添加两行代码

                var SERVER_IP = process.env.IP;
                var SERVER_PORT = process.env.PORT;
                - 将url改为Cloud9生成的preview地址
                - 将 Host，IP 分别指定为 SERVER_IP，SERVER_PORT
                - 保存 并输入 &quot;npm start&quot; 即可开启你的Blog

                &gt; 关于更改Blog主题

                - 进入网址 [http://marketplace.ghost.org/](http://marketplace.ghost.org/)
                - 选择你喜欢的主题，下载
                - 上传主题文件夹到	\content\themes\
                - ctrl + C 停止Ghost 再重启
                - 进入设置页面即可更换主题

                &gt;最新修改，已经将Blog迁移至BAE。

                由于更换了Mysql作为数据库，就不得不把先前存在Sqlite的东西拿出来了~




            </column>
            <column name="html">&lt;p&gt;折腾了周末两天时间，算是把Ghost这个东西部署好了，先后尝试了&lt;a href=&quot;http://developer.baidu.com/cloud/rt&quot;&gt;BAE&lt;/a&gt;（提示已经欠费）,&lt;a href=&quot;http://appengine.jd.com/product/jae.html&quot;&gt;JAE&lt;/a&gt;(啥破玩意建立个应用都要卡半年？)以及之前牛人推荐的 &lt;a href=&quot;nitrous.io/&quot;&gt;Nitrous.IO&lt;/a&gt;（其实这个还好，只是因为被墙的原因国内访问速度有相当大的问题）&lt;/p&gt;

                &lt;p&gt;最后，想起来先前用的Cloud 9，就上来尝试了一下。&lt;/p&gt;

                &lt;hr /&gt;

                &lt;blockquote&gt;
                &lt;p&gt;项目创建方法&lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;ul&gt;
                &lt;li&gt;登陆&lt;a href=&quot;c9.io/&quot;&gt;Cloud9&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;注册一个账号&lt;/li&gt;
                &lt;li&gt;新建一个WorkSpace 指定为 Node&lt;/li&gt;
                &lt;li&gt;下载最新的&lt;a href=&quot;http://www.ghostchina.com/download/&quot;&gt;Ghost&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;上传全部文件或ZIP压缩包到你的WorkSpace&lt;/li&gt;
                &lt;li&gt;npm install --production&lt;/li&gt;
                &lt;li&gt;&lt;p&gt;打开config.js文件 添加两行代码&lt;/p&gt;

                &lt;pre&gt;&lt;code&gt;var SERVER_IP = process.env.IP;
                var SERVER_PORT = process.env.PORT;
                &lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
                &lt;li&gt;将url改为Cloud9生成的preview地址&lt;/li&gt;
                &lt;li&gt;将 Host，IP 分别指定为 SERVER&lt;em&gt;IP，SERVER&lt;/em&gt;PORT&lt;/li&gt;
                &lt;li&gt;保存 并输入 &quot;npm start&quot; 即可开启你的Blog&lt;/li&gt;
                &lt;/ul&gt;

                &lt;blockquote&gt;
                &lt;p&gt;关于更改Blog主题&lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;ul&gt;
                &lt;li&gt;进入网址 &lt;a href=&quot;http://marketplace.ghost.org/&quot;&gt;http://marketplace.ghost.org/&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;选择你喜欢的主题，下载&lt;/li&gt;
                &lt;li&gt;上传主题文件夹到    \content\themes\&lt;/li&gt;
                &lt;li&gt;ctrl + C 停止Ghost 再重启&lt;/li&gt;
                &lt;li&gt;进入设置页面即可更换主题&lt;/li&gt;
                &lt;/ul&gt;

                &lt;blockquote&gt;
                &lt;p&gt;最新修改，已经将Blog迁移至BAE。&lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;p&gt;由于更换了Mysql作为数据库，就不得不把先前存在Sqlite的东西拿出来了~&lt;/p&gt;</column>
            <column name="image">NULL</column>
            <column name="featured">0</column>
            <column name="page">0</column>
            <column name="status">published</column>
            <column name="language">en_US</column>
            <column name="meta_title">NULL</column>
            <column name="meta_description">NULL</column>
            <column name="author_id">1</column>
            <column name="created_at">2014-06-28 15:37:29</column>
            <column name="created_by">1</column>
            <column name="updated_at">2015-04-02 16:25:15</column>
            <column name="updated_by">1</column>
            <column name="published_at">2014-06-28 16:37:29</column>
            <column name="published_by">1</column>
        </table>
        <table name="posts">
            <column name="id">2</column>
            <column name="uuid">09b48b86-3174-4ef9-8281-79c10336a1e6</column>
            <column name="title">Android自定义控件HintSeekBar开发（一）</column>
            <column name="slug">androidzi-ding-yi-kong-jian-hintseekbarkai-fa-2</column>
            <column name="markdown">
                ####思路

                1.首先根据你的需求在图纸上画出控件的盒子模型结构图。

                2.画出后根据你制定的结构通过自定义继承view或viewgroup来实现相应的自定义空间效果。

                3.重载并修改onMeasure与onLayout方法来计算控件自身大小（如果包含子控件则根据需要放置子控件）。

                4.在类内部添加用语保存控件信息的变量，总之就是一切用语描述控件外观状态的信息，目的在于任何人看到相关的信息之后都能根据你保存的信息绘制出同样的控件造型。

                5.通过复写onDispatchTouchEvent, onInterceptTouchEvent, onTouchEvent来实现用户触摸控件时对相关的参数变量进行修改，并调用view的oninvalid方法来请求调用onDraw方法刷新界面。

                6.通过重载onDraw方法来根据相关的参数绘制你的自定义控件。

                #####    到此为止你的一个简单的自定义空间就算制作成功啦！当然，如果要实现更加方便的自定义空间，你还需要在attr.xml文件内部加上你的自定义控件的相关参数接口，通过这些接口，我们便可以更加方便的在xml界面文件的内部直接给我们的空间进行初始化参数设置，就更加方便啦！


                先打个写博客计划的草稿，明天下班后一篇一篇附图补上！

                （一）自定义控件篇
                （二）百度地图开发篇
                （三）安卓动画篇</column>
            <column name="html">&lt;h4 id=&quot;&quot;&gt;思路&lt;/h4&gt;

                &lt;pre&gt;&lt;code&gt;1.首先根据你的需求在图纸上画出控件的盒子模型结构图。

                2.画出后根据你制定的结构通过自定义继承view或viewgroup来实现相应的自定义空间效果。

                3.重载并修改onMeasure与onLayout方法来计算控件自身大小（如果包含子控件则根据需要放置子控件）。

                4.在类内部添加用语保存控件信息的变量，总之就是一切用语描述控件外观状态的信息，目的在于任何人看到相关的信息之后都能根据你保存的信息绘制出同样的控件造型。

                5.通过复写onDispatchTouchEvent, onInterceptTouchEvent, onTouchEvent来实现用户触摸控件时对相关的参数变量进行修改，并调用view的oninvalid方法来请求调用onDraw方法刷新界面。

                6.通过重载onDraw方法来根据相关的参数绘制你的自定义控件。
                &lt;/code&gt;&lt;/pre&gt;

                &lt;h5 id=&quot;attrxmlxml&quot;&gt;到此为止你的一个简单的自定义空间就算制作成功啦！当然，如果要实现更加方便的自定义空间，你还需要在attr.xml文件内部加上你的自定义控件的相关参数接口，通过这些接口，我们便可以更加方便的在xml界面文件的内部直接给我们的空间进行初始化参数设置，就更加方便啦！&lt;/h5&gt;

                &lt;p&gt;先打个写博客计划的草稿，明天下班后一篇一篇附图补上！&lt;/p&gt;

                &lt;p&gt;（一）自定义控件篇
                （二）百度地图开发篇
                （三）安卓动画篇&lt;/p&gt;</column>
            <column name="image">NULL</column>
            <column name="featured">0</column>
            <column name="page">0</column>
            <column name="status">published</column>
            <column name="language">en_US</column>
            <column name="meta_title">NULL</column>
            <column name="meta_description">NULL</column>
            <column name="author_id">1</column>
            <column name="created_at">2015-03-13 16:56:10</column>
            <column name="created_by">1</column>
            <column name="updated_at">2015-04-01 15:30:04</column>
            <column name="updated_by">1</column>
            <column name="published_at">2015-03-13 16:56:16</column>
            <column name="published_by">1</column>
        </table>
        <table name="posts">
            <column name="id">3</column>
            <column name="uuid">7997eb1c-13ba-4781-97fb-6f71c0d3f94e</column>
            <column name="title">FireBase 学习（一）</column>
            <column name="slug">firebase-xue-xi</column>
            <column name="markdown">&gt;**构建利用数据库的实时Application**

                ---

                [FireBase](https://www.firebase.com/)

                利用FireBase进行数据存储时一种跟以往操作数据库不同的方式。

                FireBase采用了JSON数据树的格式进行数据的存储

                操作方法有如下：

                - SetValue
                - Update
                - Push

                ---

                &gt;**如何实现实时应用**

                官网有例子关于一个App上进行实时的绘画操作，所有人同时操作同一块画板

                ---
                &gt;**代码示例**

                - 创建实例

                Firebase fb = new Firebase('https://&lt;your-firebase&gt;.firebaseio.com');

                - 存储数据

                fb.setValue(&quot;Alex Wolfe&quot;);

                - 实时更新

                fb.addValueEventListener(new ValueEventListener() {
                @Override
                public void onDataChange(DataSnapshot snap) {
                System.out.println(snap.getName() + &quot; -&gt; &quot; + snap.getValue();
                }
                @Override
                public void onCancelled(FirebaseError error) {
                }
                });


            </column>
            <column name="html">&lt;blockquote&gt;
                &lt;p&gt;&lt;strong&gt;构建利用数据库的实时Application&lt;/strong&gt;&lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;hr /&gt;

                &lt;p&gt;&lt;a href=&quot;https://www.firebase.com/&quot;&gt;FireBase&lt;/a&gt;&lt;/p&gt;

                &lt;p&gt;利用FireBase进行数据存储时一种跟以往操作数据库不同的方式。&lt;/p&gt;

                &lt;p&gt;FireBase采用了JSON数据树的格式进行数据的存储&lt;/p&gt;

                &lt;p&gt;操作方法有如下：&lt;/p&gt;

                &lt;ul&gt;
                &lt;li&gt;SetValue&lt;/li&gt;
                &lt;li&gt;Update&lt;/li&gt;
                &lt;li&gt;Push&lt;/li&gt;
                &lt;/ul&gt;

                &lt;hr /&gt;

                &lt;blockquote&gt;
                &lt;p&gt;&lt;strong&gt;如何实现实时应用&lt;/strong&gt;&lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;p&gt;官网有例子关于一个App上进行实时的绘画操作，所有人同时操作同一块画板&lt;/p&gt;

                &lt;hr /&gt;

                &lt;blockquote&gt;
                &lt;p&gt;&lt;strong&gt;代码示例&lt;/strong&gt;&lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;ul&gt;
                &lt;li&gt;&lt;p&gt;创建实例&lt;/p&gt;

                &lt;pre&gt;&lt;code&gt;Firebase fb = new Firebase('https://&amp;lt;your-firebase&amp;gt;.firebaseio.com');
                &lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
                &lt;li&gt;&lt;p&gt;存储数据&lt;/p&gt;

                &lt;pre&gt;&lt;code&gt;fb.setValue(&quot;Alex Wolfe&quot;);
                &lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
                &lt;li&gt;&lt;p&gt;实时更新&lt;/p&gt;

                &lt;pre&gt;&lt;code&gt;fb.addValueEventListener(new ValueEventListener() {
                @Override
                public void onDataChange(DataSnapshot snap) {
                System.out.println(snap.getName() + &quot; -&amp;gt; &quot; + snap.getValue();
                }
                @Override
                public void onCancelled(FirebaseError error) {
                }
                });
                &lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
                &lt;/ul&gt;</column>
            <column name="image">NULL</column>
            <column name="featured">0</column>
            <column name="page">0</column>
            <column name="status">published</column>
            <column name="language">en_US</column>
            <column name="meta_title">NULL</column>
            <column name="meta_description">NULL</column>
            <column name="author_id">1</column>
            <column name="created_at">2014-09-17 17:03:26</column>
            <column name="created_by">1</column>
            <column name="updated_at">2015-04-01 15:30:35</column>
            <column name="updated_by">1</column>
            <column name="published_at">2014-09-17 19:03:26</column>
            <column name="published_by">1</column>
        </table>
        <table name="posts">
            <column name="id">4</column>
            <column name="uuid">6e83125e-5c37-46c6-baa2-4830c49777a4</column>
            <column name="title">FireBase 学习（二）</column>
            <column name="slug">firebase-xue-xi-er</column>
            <column name="markdown">&gt;###用FireBase实现的聊天以及互相定位功能


                - 首先我们需要定义一个class来存储每一条聊天信息
                - 且要实现一个空的构造函数便于Firebase来实现一些内部的接口函数
                - 从Firebase里新建一个child &quot;chats&quot;
                - 链接至FireBase之后为这个child创建childEventListener
                - 这个Listener可以监听该分支下面数据的 增 改 删 取消()

                // Required default constructor for Firebase object mapping    		@SuppressWarnings(&quot;unused&quot;)
                public Chat(){}
                public Chat(String msg,String sen,String ti){
                message = msg;
                sender = sen;
                time = ti;
                }

                ---

                &gt;###监听新消息采用如下方式实现

                - 首先用在Application 或 Service 中简历监听Listener
                - 在聊天界面的OnResume与OnPause里面注册与反注册一个Activity级别的Receiver
                - 在Manifest注册一个全局的Receiver用来发出Notification
                - 两个Receiver均接受同一条广播信息
                - 收到chats Child 的数据更改后发起Broadcast
                - 使得动态注册的Receiver优先级高于全局注册的，若能被Activity中的Receiver捕获该条广播，则说明在Activity中，并abord掉广播的继续传播，避免发出Notification



            </column>
            <column name="html">&lt;blockquote&gt;
                &lt;h3 id=&quot;firebase&quot;&gt;用FireBase实现的聊天以及互相定位功能&lt;/h3&gt;
                &lt;/blockquote&gt;

                &lt;ul&gt;
                &lt;li&gt;首先我们需要定义一个class来存储每一条聊天信息&lt;/li&gt;
                &lt;li&gt;且要实现一个空的构造函数便于Firebase来实现一些内部的接口函数&lt;/li&gt;
                &lt;li&gt;从Firebase里新建一个child &quot;chats&quot;&lt;/li&gt;
                &lt;li&gt;链接至FireBase之后为这个child创建childEventListener&lt;/li&gt;
                &lt;li&gt;&lt;p&gt;这个Listener可以监听该分支下面数据的 增 改 删 取消()&lt;/p&gt;

                &lt;pre&gt;&lt;code&gt;// Required default constructor for Firebase object mapping         @SuppressWarnings(&quot;unused&quot;)
                public Chat(){}
                public Chat(String msg,String sen,String ti){
                message = msg;
                sender = sen;
                time = ti;
                }
                &lt;/code&gt;&lt;/pre&gt;

                &lt;hr /&gt;&lt;/li&gt;
                &lt;/ul&gt;

                &lt;blockquote&gt;
                &lt;h3 id=&quot;&quot;&gt;监听新消息采用如下方式实现&lt;/h3&gt;
                &lt;/blockquote&gt;

                &lt;ul&gt;
                &lt;li&gt;首先用在Application 或 Service 中简历监听Listener&lt;/li&gt;
                &lt;li&gt;在聊天界面的OnResume与OnPause里面注册与反注册一个Activity级别的Receiver&lt;/li&gt;
                &lt;li&gt;在Manifest注册一个全局的Receiver用来发出Notification&lt;/li&gt;
                &lt;li&gt;两个Receiver均接受同一条广播信息&lt;/li&gt;
                &lt;li&gt;收到chats Child 的数据更改后发起Broadcast&lt;/li&gt;
                &lt;li&gt;使得动态注册的Receiver优先级高于全局注册的，若能被Activity中的Receiver捕获该条广播，则说明在Activity中，并abord掉广播的继续传播，避免发出Notification&lt;/li&gt;
                &lt;/ul&gt;</column>
            <column name="image">NULL</column>
            <column name="featured">0</column>
            <column name="page">0</column>
            <column name="status">published</column>
            <column name="language">en_US</column>
            <column name="meta_title">NULL</column>
            <column name="meta_description">NULL</column>
            <column name="author_id">1</column>
            <column name="created_at">2014-09-24 17:03:53</column>
            <column name="created_by">1</column>
            <column name="updated_at">2015-04-01 15:30:43</column>
            <column name="updated_by">1</column>
            <column name="published_at">2014-09-24 19:03:53</column>
            <column name="published_by">1</column>
        </table>
        <table name="posts">
            <column name="id">5</column>
            <column name="uuid">6d7f5686-6c8d-4986-9365-a21cac98a893</column>
            <column name="title">Smart Plank</column>
            <column name="slug">smart-plank</column>
            <column name="markdown">&gt;###Smart Plank

                ---

                &lt;center&gt;![](http://t.williamgates.net/image-ED6E_53F2A4AC.jpg)&lt;/center&gt;

                ---

                - Smart Plank is a app that brings much more pleasure when doing your plank.
                - You can also share a link to your friends by wechat to start a real-time fight.
                - Doesn't it intract you?

                ---
                &gt;###Just Wait...</column>
            <column name="html">&lt;blockquote&gt;
                &lt;h3 id=&quot;smartplank&quot;&gt;Smart Plank&lt;/h3&gt;
                &lt;/blockquote&gt;

                &lt;hr /&gt;

                &lt;p&gt;&lt;center&gt;&lt;img src=&quot;http://t.williamgates.net/image-ED6E_53F2A4AC.jpg&quot; alt=&quot;&quot; title=&quot;&quot; /&gt;&lt;/center&gt;&lt;/p&gt;

                &lt;hr /&gt;

                &lt;ul&gt;
                &lt;li&gt;Smart Plank is a app that brings much more pleasure when doing your plank.&lt;/li&gt;
                &lt;li&gt;You can also share a link to your friends by wechat to start a real-time fight.&lt;/li&gt;
                &lt;li&gt;Doesn't it intract you?&lt;/li&gt;
                &lt;/ul&gt;

                &lt;hr /&gt;

                &lt;blockquote&gt;
                &lt;h3 id=&quot;justwait&quot;&gt;Just Wait...&lt;/h3&gt;
                &lt;/blockquote&gt;</column>
            <column name="image">NULL</column>
            <column name="featured">0</column>
            <column name="page">0</column>
            <column name="status">published</column>
            <column name="language">en_US</column>
            <column name="meta_title">NULL</column>
            <column name="meta_description">NULL</column>
            <column name="author_id">1</column>
            <column name="created_at">2014-10-22 17:04:28</column>
            <column name="created_by">1</column>
            <column name="updated_at">2015-04-01 15:30:53</column>
            <column name="updated_by">1</column>
            <column name="published_at">2014-10-22 22:04:28</column>
            <column name="published_by">1</column>
        </table>
        <table name="posts">
            <column name="id">6</column>
            <column name="uuid">76f3ba95-6bed-4fc5-aa6d-86cbcdd610b3</column>
            <column name="title">Android 自定义Bootstrap风格Button</column>
            <column name="slug">android-zi-ding-yi-bootstrapfeng-ge-button</column>
            <column name="markdown">&gt;自定义Button 用代码实现XML中定义的Selector效果

                - 首先需要自定义attr属性

                &lt;resources&gt;
                &lt;!--Button--&gt;
                &lt;declare-styleable name=&quot;BeautyButton&quot;&gt;
                &lt;attr name=&quot;isEmpty&quot; format=&quot;boolean&quot;/&gt;
                &lt;attr name=&quot;colorNormal&quot; format=&quot;color|reference&quot;/&gt;
                &lt;attr name=&quot;colorClick&quot; format=&quot;color|reference&quot;/&gt;
                &lt;attr name=&quot;corner&quot; format=&quot;dimension&quot;/&gt;
                &lt;attr name=&quot;strokeWidth&quot; format=&quot;dimension&quot;/&gt;
                &lt;attr name=&quot;strokeColorNormal&quot; format=&quot;color|reference&quot;/&gt;
                &lt;attr name=&quot;strokeColorClick&quot; format=&quot;color|reference&quot;/&gt;
                &lt;attr name=&quot;textColorNormal&quot; format=&quot;color|reference&quot;/&gt;
                &lt;attr name=&quot;textColorClick&quot; format=&quot;color|reference&quot;/&gt;
                &lt;attr name=&quot;textSize&quot; format=&quot;dimension&quot;/&gt;
                &lt;attr name=&quot;clickAnimation&quot; format=&quot;enum&quot;&gt;
                &lt;enum name=&quot;SHAKE&quot; value=&quot;0&quot; /&gt;
                &lt;enum name=&quot;FADE_OUT&quot; value=&quot;1&quot; /&gt;
                &lt;enum name=&quot;LEFT&quot; value=&quot;2&quot; /&gt;
                &lt;/attr&gt;
                &lt;/declare-styleable&gt;
                &lt;/resources&gt;


                上面定义了按钮的背景色(两个状态)，文字的颜色(两个状态),圆角的程度，描边的颜色以及宽度。

                - 自定义类继承Button类

                private void initAttr(Context context,AttributeSet attrs){
                TypedArray appearance = context.obtainStyledAttributes(attrs, R.styleable.BeautyButton,0,0);
                if(appearance == null)
                return;
                /**
                * 首先判断是否空心 (低层次的默认色没有写进去 1-&gt;默认白色 2-&gt;默认蓝色)
                *
                * 情况1(空心) : 获取常规色(默认白色) -&gt; 获取点击色 -&gt; 获取描边色(默认点击色) -&gt; 获取字体色(默认点击色) -&gt; 字体点击色(默认常规色)
                *
                * 情况2(实心) : 获取常规色(蓝色) -&gt; 获取点击色(默认加重) -&gt; 获取字体色 -&gt; 字体点击色
                */
                //应该在此获取一下宽度和高度
                mIsEmpty = appearance.getBoolean(R.styleable.BeautyButton_isEmpty,false);//默认是实心
                if(mIsEmpty){
                //step 01 大体颜色
                mBtnColorNormal = appearance.getColor(R.styleable.BeautyButton_colorNormal, Color.rgb(255,255,255));//默认白色
                mBtnColorClick = appearance.getColor(R.styleable.BeautyButton_colorClick,Color.rgb(1,154,255));//默认蓝色
                //step 02 描边颜色 宽度
                mBtnStrokeNormal = appearance.getColor(R.styleable.BeautyButton_strokeColorNormal,mBtnColorClick);//默认是点击色
                mBtnStrokeClick = appearance.getColor(R.styleable.BeautyButton_strokeColorClick,mBtnStrokeNormal);//描边色默认一致
                mStrokeWidth = appearance.getDimension(R.styleable.BeautyButton_strokeWidth,getResources().getDimension(R.dimen.strokeDefault));
                //step 03 字体颜色
                mTextColorNormal = appearance.getColor(R.styleable.BeautyButton_textColorNormal,mBtnColorClick);//默认点击色
                mTextColorClick = appearance.getColor(R.styleable.BeautyButton_textColorClick,mBtnColorNormal);//默认常规色
                //step 04 边角(应该默认值是计算出来等于高度的一半)
                mCorner = appearance.getDimension(R.styleable.BeautyButton_corner,getResources().getDimension(R.dimen.strokeDefault));
                }else{
                //step 01 大体颜色
                mBtnColorNormal = appearance.getColor(R.styleable.BeautyButton_colorNormal, Color.rgb(1,154,255));//默认蓝色
                mBtnColorClick = appearance.getColor(R.styleable.BeautyButton_colorClick,Color.rgb(1,200,255));//默认蓝色加深
                //step 02 描边颜色 宽度
                mBtnStrokeNormal = appearance.getColor(R.styleable.BeautyButton_strokeColorNormal,mBtnColorNormal);//默认是点击色
                mBtnStrokeClick = appearance.getColor(R.styleable.BeautyButton_strokeColorClick,mBtnColorClick);//描边色默认一致
                mStrokeWidth = appearance.getDimension(R.styleable.BeautyButton_strokeWidth,getResources().getDimension(R.dimen.strokeDefault));
                //step 03 字体颜色
                mTextColorNormal = appearance.getColor(R.styleable.BeautyButton_textColorNormal,Color.rgb(0,0,0));//默认点击色
                mTextColorClick = appearance.getColor(R.styleable.BeautyButton_textColorClick,Color.rgb(55,55,55));//默认常规色
                //step 04 边角(应该默认值是计算出来等于高度的一半)
                mCorner = appearance.getDimension(R.styleable.BeautyButton_corner,getResources().getDimension(R.dimen.strokeDefault));
                }
                appearance.recycle();//用处何在？
                }</column>
            <column name="html">&lt;blockquote&gt;
                &lt;p&gt;自定义Button 用代码实现XML中定义的Selector效果&lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;ul&gt;
                &lt;li&gt;&lt;p&gt;首先需要自定义attr属性&lt;/p&gt;

                &lt;pre&gt;&lt;code&gt;&amp;lt;resources&amp;gt;
                &amp;lt;!--Button--&amp;gt;
                &amp;lt;declare-styleable name=&quot;BeautyButton&quot;&amp;gt;
                &amp;lt;attr name=&quot;isEmpty&quot; format=&quot;boolean&quot;/&amp;gt;
                &amp;lt;attr name=&quot;colorNormal&quot; format=&quot;color|reference&quot;/&amp;gt;
                &amp;lt;attr name=&quot;colorClick&quot; format=&quot;color|reference&quot;/&amp;gt;
                &amp;lt;attr name=&quot;corner&quot; format=&quot;dimension&quot;/&amp;gt;
                &amp;lt;attr name=&quot;strokeWidth&quot; format=&quot;dimension&quot;/&amp;gt;
                &amp;lt;attr name=&quot;strokeColorNormal&quot; format=&quot;color|reference&quot;/&amp;gt;
                &amp;lt;attr name=&quot;strokeColorClick&quot; format=&quot;color|reference&quot;/&amp;gt;
                &amp;lt;attr name=&quot;textColorNormal&quot; format=&quot;color|reference&quot;/&amp;gt;
                &amp;lt;attr name=&quot;textColorClick&quot; format=&quot;color|reference&quot;/&amp;gt;
                &amp;lt;attr name=&quot;textSize&quot; format=&quot;dimension&quot;/&amp;gt;
                &amp;lt;attr name=&quot;clickAnimation&quot; format=&quot;enum&quot;&amp;gt;
                &amp;lt;enum name=&quot;SHAKE&quot; value=&quot;0&quot; /&amp;gt;
                &amp;lt;enum name=&quot;FADE_OUT&quot; value=&quot;1&quot; /&amp;gt;
                &amp;lt;enum name=&quot;LEFT&quot; value=&quot;2&quot; /&amp;gt;
                &amp;lt;/attr&amp;gt;
                &amp;lt;/declare-styleable&amp;gt;
                &amp;lt;/resources&amp;gt;
                &lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
                &lt;/ul&gt;

                &lt;p&gt;上面定义了按钮的背景色(两个状态)，文字的颜色(两个状态),圆角的程度，描边的颜色以及宽度。&lt;/p&gt;

                &lt;ul&gt;
                &lt;li&gt;&lt;p&gt;自定义类继承Button类&lt;/p&gt;

                &lt;pre&gt;&lt;code&gt;private void initAttr(Context context,AttributeSet attrs){
                TypedArray appearance = context.obtainStyledAttributes(attrs, R.styleable.BeautyButton,0,0);
                if(appearance == null)
                return;
                /**
                * 首先判断是否空心 (低层次的默认色没有写进去 1-&amp;gt;默认白色 2-&amp;gt;默认蓝色)
                *
                * 情况1(空心) : 获取常规色(默认白色) -&amp;gt; 获取点击色 -&amp;gt; 获取描边色(默认点击色) -&amp;gt; 获取字体色(默认点击色) -&amp;gt; 字体点击色(默认常规色)
                *
                * 情况2(实心) : 获取常规色(蓝色) -&amp;gt; 获取点击色(默认加重) -&amp;gt; 获取字体色 -&amp;gt; 字体点击色
                */
                //应该在此获取一下宽度和高度
                mIsEmpty = appearance.getBoolean(R.styleable.BeautyButton_isEmpty,false);//默认是实心
                if(mIsEmpty){
                //step 01 大体颜色
                mBtnColorNormal = appearance.getColor(R.styleable.BeautyButton_colorNormal, Color.rgb(255,255,255));//默认白色
                mBtnColorClick = appearance.getColor(R.styleable.BeautyButton_colorClick,Color.rgb(1,154,255));//默认蓝色
                //step 02 描边颜色 宽度
                mBtnStrokeNormal = appearance.getColor(R.styleable.BeautyButton_strokeColorNormal,mBtnColorClick);//默认是点击色
                mBtnStrokeClick = appearance.getColor(R.styleable.BeautyButton_strokeColorClick,mBtnStrokeNormal);//描边色默认一致
                mStrokeWidth = appearance.getDimension(R.styleable.BeautyButton_strokeWidth,getResources().getDimension(R.dimen.strokeDefault));
                //step 03 字体颜色
                mTextColorNormal = appearance.getColor(R.styleable.BeautyButton_textColorNormal,mBtnColorClick);//默认点击色
                mTextColorClick = appearance.getColor(R.styleable.BeautyButton_textColorClick,mBtnColorNormal);//默认常规色
                //step 04 边角(应该默认值是计算出来等于高度的一半)
                mCorner = appearance.getDimension(R.styleable.BeautyButton_corner,getResources().getDimension(R.dimen.strokeDefault));
                }else{
                //step 01 大体颜色
                mBtnColorNormal = appearance.getColor(R.styleable.BeautyButton_colorNormal, Color.rgb(1,154,255));//默认蓝色
                mBtnColorClick = appearance.getColor(R.styleable.BeautyButton_colorClick,Color.rgb(1,200,255));//默认蓝色加深
                //step 02 描边颜色 宽度
                mBtnStrokeNormal = appearance.getColor(R.styleable.BeautyButton_strokeColorNormal,mBtnColorNormal);//默认是点击色
                mBtnStrokeClick = appearance.getColor(R.styleable.BeautyButton_strokeColorClick,mBtnColorClick);//描边色默认一致
                mStrokeWidth = appearance.getDimension(R.styleable.BeautyButton_strokeWidth,getResources().getDimension(R.dimen.strokeDefault));
                //step 03 字体颜色
                mTextColorNormal = appearance.getColor(R.styleable.BeautyButton_textColorNormal,Color.rgb(0,0,0));//默认点击色
                mTextColorClick = appearance.getColor(R.styleable.BeautyButton_textColorClick,Color.rgb(55,55,55));//默认常规色
                //step 04 边角(应该默认值是计算出来等于高度的一半)
                mCorner = appearance.getDimension(R.styleable.BeautyButton_corner,getResources().getDimension(R.dimen.strokeDefault));
                }
                appearance.recycle();//用处何在？
                }
                &lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
                &lt;/ul&gt;</column>
            <column name="image">NULL</column>
            <column name="featured">0</column>
            <column name="page">0</column>
            <column name="status">published</column>
            <column name="language">en_US</column>
            <column name="meta_title">NULL</column>
            <column name="meta_description">NULL</column>
            <column name="author_id">1</column>
            <column name="created_at">2014-11-27 17:05:08</column>
            <column name="created_by">1</column>
            <column name="updated_at">2015-04-01 15:31:10</column>
            <column name="updated_by">1</column>
            <column name="published_at">2014-11-27 19:05:08</column>
            <column name="published_by">1</column>
        </table>
        <table name="posts">
            <column name="id">7</column>
            <column name="uuid">16286eba-e25d-457e-9d64-94cf75ad7a04</column>
            <column name="title">Android 自定义控件 SnackBar</column>
            <column name="slug">android-zi-ding-yi-bootstrapfeng-ge-button-er</column>
            <column name="markdown">&gt;实现Material Design中的SnackBar功能


                感谢Github上的两个项目，都非常的出色

                [MrEngineer13/SnackBar](https://github.com/MrEngineer13/SnackBar) /
                [wmora/snackbar](https://github.com/wmora/snackbar)

                以及国内一个特别屌的大神 [Daimajia](https://github.com/w446108264/AndroidViewHover) 做的很多动画以及控件都非常的出色，也是从他身上总结了自己很多的不足之处，也希望大神能够多多发项目，可以向您多多学习！

                下面开始讲一讲自己的思路

                ---

                - 建立类读取布局
                - 获取当前Activity的根控件
                - 根据数量插入新的Snackbar
                - 实现动画效果</column>
            <column name="html">&lt;blockquote&gt;
                &lt;p&gt;实现Material Design中的SnackBar功能&lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;p&gt;感谢Github上的两个项目，都非常的出色&lt;/p&gt;

                &lt;p&gt;&lt;a href=&quot;https://github.com/MrEngineer13/SnackBar&quot;&gt;MrEngineer13/SnackBar&lt;/a&gt; /
                &lt;a href=&quot;https://github.com/wmora/snackbar&quot;&gt;wmora/snackbar&lt;/a&gt;&lt;/p&gt;

                &lt;p&gt;以及国内一个特别屌的大神 &lt;a href=&quot;https://github.com/w446108264/AndroidViewHover&quot;&gt;Daimajia&lt;/a&gt; 做的很多动画以及控件都非常的出色，也是从他身上总结了自己很多的不足之处，也希望大神能够多多发项目，可以向您多多学习！&lt;/p&gt;

                &lt;p&gt;下面开始讲一讲自己的思路&lt;/p&gt;

                &lt;hr /&gt;

                &lt;ul&gt;
                &lt;li&gt;建立类读取布局&lt;/li&gt;
                &lt;li&gt;获取当前Activity的根控件&lt;/li&gt;
                &lt;li&gt;根据数量插入新的Snackbar&lt;/li&gt;
                &lt;li&gt;实现动画效果&lt;/li&gt;
                &lt;/ul&gt;</column>
            <column name="image">NULL</column>
            <column name="featured">0</column>
            <column name="page">0</column>
            <column name="status">published</column>
            <column name="language">en_US</column>
            <column name="meta_title">NULL</column>
            <column name="meta_description">NULL</column>
            <column name="author_id">1</column>
            <column name="created_at">2014-12-25 17:05:37</column>
            <column name="created_by">1</column>
            <column name="updated_at">2015-04-01 15:31:21</column>
            <column name="updated_by">1</column>
            <column name="published_at">2014-12-25 19:05:37</column>
            <column name="published_by">1</column>
        </table>
        <table name="posts">
            <column name="id">8</column>
            <column name="uuid">df305c54-7fcd-4a22-9d1c-ef6a426e063e</column>
            <column name="title">Android自定义控件HintSeekBar开发（二）</column>
            <column name="slug">androidzi-ding-yi-kong-jian-hintseekbarkai-fa-er</column>
            <column name="markdown">上一篇Blog中大致说了一下开发设计的思路，这次就开始着重HintSeekBar的开发工作.


                ![控件的使用效果](http://i2.tietuku.com/2809944a53e8c882.gif)

                &lt;del&gt;下面的文字位置应该稍稍往下一点...&lt;/del&gt;


                讲一下我比较笨拙的思路吧：

                - 首先你要用一些变量值去控制图中各个元素的粗细，颜色，位置。
                - 其次需要重载onMeasuer函数来计算控件所需要占得大小，也就是包含了text, bar, dot, hint 这几部分的总共大小。
                - 在下一步就是通过onTouchEvent来根据触摸事件来改变相应的变量值，在每次改变后调用invalidate()方法来实现界面的刷新效果。
                - 新建几个子线程以及Handler来处理一下触摸结束后的动画“余波”效果。


                ######那么首先我们来定义一下所需要的变量
                ```private final static int IDLE = 0, MOVING = 1;
                private final static int BIG_RADIUS = 44, SMALL_RADIUS = 28;
                //  可以指定或是获取的
                private int mMax = 30;
                private int mTickNumber = 6;    //  几个刻度
                private int mNorProgress = 0;
                //  标志位
                private int mNowState = IDLE;      //  当前处于哪种状态
                private int mIdleRadius = 28;    //  静止时的半径
                private int mMovingRadius = 28;  //  移动时候的半径
                private int mHintRadius = 52;    //  依次递增
                private int mHintTextSize = 48;  //  提示文字的大小
                private float mHintX;
                private int mIdleColor = Color.rgb(255, 67, 50);     //  静止时的颜色
                private int mMovingColor = Color.rgb(255,67,50);   //  滑动时的颜色
                private int mHintColor = Color.rgb(63,81,181);     //  提示背景色
                private int mHintTextColor = Color.WHITE; //  提示文字颜色
                private int mLineIdleHeight = 4;//  线粗细
                private int mLineCoverHeight = 10;
                private int mLineLeftX; //  开始位置
                private int mLineRightX;//  结束位置
                private int mTickHeight = 24 ;    //  刻度的高度
                private int mTickWidth = 8 ;     //  刻度的宽度
                private int mTickColor = Color.GRAY;     //  刻度的颜色
                private int mLineIdleColor = Color.GRAY;   //  线的基本色
                private int mLineCoverColor = Color.rgb(255,67,50);    //  线的覆盖色
                private int CH; //  线的Y坐标
                private int mHintYOffset = 0;       //  用于控制提示框的上下移动与透明度
                private int mHintAlphaOffset = 0;
                ```

                是不是看起来多的要命，其实因为我比较偷懒没有做一些简化啦，其中很多参数其实都是有相互之间的关系的，通过某几个完全可以计算出其他几个，但这样其实更加直白一点，就这么写了。


                ######接下来就是对onMeasuer方法的修改

                &lt;code&gt;
                @Override
                protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
                //  获取控件的高度以及宽度来计算
                super.onMeasure(widthMeasureSpec, heightMeasureSpec);
                mLineLeftX = getPaddingLeft() + mHintRadius;
                mLineRightX = getWidth() - getPaddingRight() - mHintRadius;
                CH = getHeight()/2 + 36;  //向下偏移 25
                //  初始值为0
                mHintX = mLineLeftX;
                }
                &lt;/code&gt;

                在这根据你的上级对你大小的大致要求，你来划一下自己想要的领土大小，并完成一些固定值的初始值的计算与赋值。

                ######接下来就是在onTouchEvent中的修改

                &lt;code&gt;
                @Override
                public boolean onTouchEvent(MotionEvent event) {
                //  符合范围才计算
                float x = event.getX();
                int offset = (int)(x - mLineLeftX);
                int target = mMax * offset / (mLineRightX - mLineLeftX);
                if(target &gt;= 0 &amp;&amp; target &lt;= mMax)
                mNorProgress = mMax * offset / (mLineRightX - mLineLeftX);
                if( x &gt;= mLineLeftX &amp;&amp; x &lt;= mLineRightX)
                mHintX = x;
                switch (event.getAction()) {
                case MotionEvent.ACTION_DOWN:
                mNowState = MOVING;
                mMovingRadius = 14;
                mHintYOffset = 26;
                mHintAlphaOffset = 234;
                //  清空消息队列
                clearAllMessage();
                handler.post(show);
                handler.post(bigger);
                break;
                case MotionEvent.ACTION_MOVE:
                break;
                case MotionEvent.ACTION_UP:
                case MotionEvent.ACTION_CANCEL:
                mMovingRadius = 22;
                mHintYOffset = 0;
                mHintAlphaOffset = 0;
                //  清空消息队列
                clearAllMessage();
                handler.post(hide);
                handler.post(smaller);
                break;
                }
                //  return True if the event was handled, false otherwise.
                invalidate();
                return true;
                }
                &lt;/code&gt;


                ######然后就是在onDraw方法中调用你的绘制方法进行界面效果的绘制

                &lt;code&gt;
                @Override
                protected void onDraw(Canvas canvas) {
                //  01 画最底层的背景色 刻度
                //  02 根据进度画出已选择的进度（颜色 + 宽度）
                //  03 根据手势状态画出指示器位置 以及改变滑动 按钮的半径
                drawBackground(canvas);
                drawTick(canvas);
                drawCover(canvas);
                drawHint(canvas);
                drawCircle(canvas);
                }
                &lt;/code&gt;

                ######最后则是完成动画“余波”的效果

                &lt;code&gt;
                Handler handler = new Handler(){
                @Override
                public void handleMessage(Message msg) {
                //  判断种类 并判断是否继续
                switch (msg.what){
                case TYPE_BIGGER:
                if(mMovingRadius &lt; BIG_RADIUS)
                handler.postDelayed(bigger,16);
                break;
                case TYPE_SMALLER:
                if(mMovingRadius &gt; SMALL_RADIUS)
                handler.postDelayed(smaller,16);
                break;
                case TYPE_SHOW:
                if(mHintYOffset &gt; 0)
                handler.postDelayed(show,5);
                break;
                case TYPE_HIDE:
                if(mHintYOffset &lt; 26)
                handler.postDelayed(hide,5);
                else
                mNowState = IDLE;
                break;
                }
                invalidate();
                }
                };
                &lt;/code&gt;
            </column>
            <column name="html">&lt;p&gt;上一篇Blog中大致说了一下开发设计的思路，这次就开始着重HintSeekBar的开发工作.&lt;/p&gt;

                &lt;p&gt;&lt;img src=&quot;http://i2.tietuku.com/2809944a53e8c882.gif&quot; alt=&quot;控件的使用效果&quot; /&gt;&lt;/p&gt;

                &lt;p&gt;&lt;del&gt;下面的文字位置应该稍稍往下一点...&lt;/del&gt;&lt;/p&gt;

                &lt;p&gt;讲一下我比较笨拙的思路吧：&lt;/p&gt;

                &lt;ul&gt;
                &lt;li&gt;首先你要用一些变量值去控制图中各个元素的粗细，颜色，位置。&lt;/li&gt;
                &lt;li&gt;其次需要重载onMeasuer函数来计算控件所需要占得大小，也就是包含了text, bar, dot, hint 这几部分的总共大小。&lt;/li&gt;
                &lt;li&gt;在下一步就是通过onTouchEvent来根据触摸事件来改变相应的变量值，在每次改变后调用invalidate()方法来实现界面的刷新效果。&lt;/li&gt;
                &lt;li&gt;新建几个子线程以及Handler来处理一下触摸结束后的动画“余波”效果。&lt;/li&gt;
                &lt;/ul&gt;

                &lt;h6 id=&quot;&quot;&gt;那么首先我们来定义一下所需要的变量&lt;/h6&gt;

                &lt;p&gt;&lt;code&gt;private final static int IDLE = 0, MOVING = 1;
                private final static int BIG_RADIUS = 44, SMALL_RADIUS = 28;
                //  可以指定或是获取的
                private int mMax = 30;
                private int mTickNumber = 6;    //  几个刻度
                private int mNorProgress = 0;
                //  标志位
                private int mNowState = IDLE;      //  当前处于哪种状态
                private int mIdleRadius = 28;    //  静止时的半径
                private int mMovingRadius = 28;  //  移动时候的半径
                private int mHintRadius = 52;    //  依次递增
                private int mHintTextSize = 48;  //  提示文字的大小
                private float mHintX;
                private int mIdleColor = Color.rgb(255, 67, 50);     //  静止时的颜色
                private int mMovingColor = Color.rgb(255,67,50);   //  滑动时的颜色
                private int mHintColor = Color.rgb(63,81,181);     //  提示背景色
                private int mHintTextColor = Color.WHITE; //  提示文字颜色
                private int mLineIdleHeight = 4;//  线粗细
                private int mLineCoverHeight = 10;
                private int mLineLeftX; //  开始位置
                private int mLineRightX;//  结束位置
                private int mTickHeight = 24 ;    //  刻度的高度
                private int mTickWidth = 8 ;     //  刻度的宽度
                private int mTickColor = Color.GRAY;     //  刻度的颜色
                private int mLineIdleColor = Color.GRAY;   //  线的基本色
                private int mLineCoverColor = Color.rgb(255,67,50);    //  线的覆盖色
                private int CH; //  线的Y坐标
                private int mHintYOffset = 0;       //  用于控制提示框的上下移动与透明度
                private int mHintAlphaOffset = 0;
                &lt;/code&gt;&lt;/p&gt;

                &lt;p&gt;是不是看起来多的要命，其实因为我比较偷懒没有做一些简化啦，其中很多参数其实都是有相互之间的关系的，通过某几个完全可以计算出其他几个，但这样其实更加直白一点，就这么写了。&lt;/p&gt;

                &lt;h6 id=&quot;onmeasuer&quot;&gt;接下来就是对onMeasuer方法的修改&lt;/h6&gt;

                &lt;p&gt;&lt;code&gt; &lt;br /&gt;
                @Override
                protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
                //  获取控件的高度以及宽度来计算
                super.onMeasure(widthMeasureSpec, heightMeasureSpec);
                mLineLeftX = getPaddingLeft() + mHintRadius;
                mLineRightX = getWidth() - getPaddingRight() - mHintRadius;
                CH = getHeight()/2 + 36;  //向下偏移 25
                //  初始值为0
                mHintX = mLineLeftX;
                }
                &lt;/code&gt;&lt;/p&gt;

                &lt;p&gt;在这根据你的上级对你大小的大致要求，你来划一下自己想要的领土大小，并完成一些固定值的初始值的计算与赋值。&lt;/p&gt;

                &lt;h6 id=&quot;ontouchevent&quot;&gt;接下来就是在onTouchEvent中的修改&lt;/h6&gt;

                &lt;p&gt;&lt;code&gt; &lt;br /&gt;
                @Override
                public boolean onTouchEvent(MotionEvent event) {
                //  符合范围才计算
                float x = event.getX();
                int offset = (int)(x - mLineLeftX);
                int target = mMax * offset / (mLineRightX - mLineLeftX);
                if(target &gt;= 0 &amp;amp;&amp;amp; target &amp;lt;= mMax)
                mNorProgress = mMax * offset / (mLineRightX - mLineLeftX);
                if( x &gt;= mLineLeftX &amp;amp;&amp;amp; x &amp;lt;= mLineRightX)
                mHintX = x;
                switch (event.getAction()) {
                case MotionEvent.ACTION&lt;em&gt;DOWN:
                mNowState = MOVING;
                mMovingRadius = 14;
                mHintYOffset = 26;
                mHintAlphaOffset = 234;
                //  清空消息队列
                clearAllMessage();
                handler.post(show);
                handler.post(bigger);
                break;
                case MotionEvent.ACTION&lt;/em&gt;MOVE:
                break;
                case MotionEvent.ACTION&lt;em&gt;UP:
                case MotionEvent.ACTION&lt;/em&gt;CANCEL:
                mMovingRadius = 22;
                mHintYOffset = 0;
                mHintAlphaOffset = 0;
                //  清空消息队列
                clearAllMessage();
                handler.post(hide);
                handler.post(smaller);
                break;
                }
                //  return True if the event was handled, false otherwise.
                invalidate();
                return true;
                }
                &lt;/code&gt;&lt;/p&gt;

                &lt;h6 id=&quot;ondraw&quot;&gt;然后就是在onDraw方法中调用你的绘制方法进行界面效果的绘制&lt;/h6&gt;

                &lt;p&gt;&lt;code&gt; &lt;br /&gt;
                @Override
                protected void onDraw(Canvas canvas) {
                //  01 画最底层的背景色 刻度
                //  02 根据进度画出已选择的进度（颜色 + 宽度）
                //  03 根据手势状态画出指示器位置 以及改变滑动 按钮的半径
                drawBackground(canvas);
                drawTick(canvas);
                drawCover(canvas);
                drawHint(canvas);
                drawCircle(canvas);
                }
                &lt;/code&gt;&lt;/p&gt;

                &lt;h6 id=&quot;&quot;&gt;最后则是完成动画“余波”的效果&lt;/h6&gt;

                &lt;p&gt;&lt;code&gt; &lt;br /&gt;
                Handler handler = new Handler(){ &lt;br /&gt;
                @Override
                public void handleMessage(Message msg) {
                //  判断种类 并判断是否继续
                switch (msg.what){
                case TYPE&lt;em&gt;BIGGER:
                if(mMovingRadius &amp;lt; BIG&lt;/em&gt;RADIUS)
                handler.postDelayed(bigger,16);
                break;
                case TYPE&lt;em&gt;SMALLER:
                if(mMovingRadius &gt; SMALL&lt;/em&gt;RADIUS)
                handler.postDelayed(smaller,16);
                break;
                case TYPE&lt;em&gt;SHOW:
                if(mHintYOffset &gt; 0)
                handler.postDelayed(show,5);
                break;
                case TYPE&lt;/em&gt;HIDE:
                if(mHintYOffset &amp;lt; 26)
                handler.postDelayed(hide,5);
                else
                mNowState = IDLE;
                break;
                }
                invalidate();
                }
                };
                &lt;/code&gt;&lt;/p&gt;</column>
            <column name="image">NULL</column>
            <column name="featured">0</column>
            <column name="page">0</column>
            <column name="status">published</column>
            <column name="language">en_US</column>
            <column name="meta_title">NULL</column>
            <column name="meta_description">NULL</column>
            <column name="author_id">1</column>
            <column name="created_at">2015-03-18 09:38:01</column>
            <column name="created_by">1</column>
            <column name="updated_at">2015-04-01 15:31:31</column>
            <column name="updated_by">1</column>
            <column name="published_at">2015-03-18 10:36:16</column>
            <column name="published_by">1</column>
        </table>
        <table name="posts">
            <column name="id">9</column>
            <column name="uuid">54ed1cf6-8a7e-45cd-a0a8-4a48c1967754</column>
            <column name="title">Android 登陆界面键盘弹出时遮盖到输入框的解决方案</column>
            <column name="slug">android-deng-lu-jie-mian-jian-pan-dan-chu-shi-zhe-gai-dao-shu-ru-kuang-de-jie-jue-fang-an</column>
            <column name="markdown">目前在项目中牵扯到HD版本的登陆问题，由于布局的需要，将登陆信息框放在了父布局的中心位置，再加上是横版的界面，用户在点击输入用户名的时候，弹出的输入框就会将密码框遮挡起来，而当用户再输入完毕账号之后，必须先将键盘隐藏，再点击密码框，造成了极大的不友好体验。

                针对这一情况，我想到了两种解决方案：

                - 1将键盘上的回车部分设置为Next（下一步），用户再点击的时候输入框焦点能够切换至密码框，
                相关资料见博文[EditText常用属性](http://blog.csdn.net/wirelessqa/article/details/8567327).
                随后在XML以及EditText代码中进行如下的修改调整。

                &lt;code&gt;android:imeOptions=&quot;actionNext&quot;
                usernameEdit.setOnEditorActionListener(new OnEditorActionListener(){
                /.....
                })
                &lt;/code&gt;

                - 2就是监听布局的大小改变情况，做一些布局上的调整，如下面的博文中做的一些列修改，可以通过动态计算布局减小的数值，来显示小的Logo并根据数值计算一下新的布局以及Logo缩放的程度。综合考虑还是第二种方案更加优秀，也增加了登陆界面的变数与动态特性。

                [仿QQ空间登录，解决键盘挡住输入框的问题](http://www.aiuxian.com/article/p-668098.html)</column>
            <column name="html">&lt;p&gt;目前在项目中牵扯到HD版本的登陆问题，由于布局的需要，将登陆信息框放在了父布局的中心位置，再加上是横版的界面，用户在点击输入用户名的时候，弹出的输入框就会将密码框遮挡起来，而当用户再输入完毕账号之后，必须先将键盘隐藏，再点击密码框，造成了极大的不友好体验。&lt;/p&gt;

                &lt;p&gt;针对这一情况，我想到了两种解决方案：&lt;/p&gt;

                &lt;ul&gt;
                &lt;li&gt;&lt;p&gt;1将键盘上的回车部分设置为Next（下一步），用户再点击的时候输入框焦点能够切换至密码框，
                相关资料见博文&lt;a href=&quot;http://blog.csdn.net/wirelessqa/article/details/8567327&quot;&gt;EditText常用属性&lt;/a&gt;.
                随后在XML以及EditText代码中进行如下的修改调整。&lt;/p&gt;

                &lt;p&gt;&lt;code&gt;android:imeOptions=&quot;actionNext&quot;
                usernameEdit.setOnEditorActionListener(new OnEditorActionListener(){ &lt;br /&gt;
                /.....
                })
                &lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
                &lt;li&gt;&lt;p&gt;2就是监听布局的大小改变情况，做一些布局上的调整，如下面的博文中做的一些列修改，可以通过动态计算布局减小的数值，来显示小的Logo并根据数值计算一下新的布局以及Logo缩放的程度。综合考虑还是第二种方案更加优秀，也增加了登陆界面的变数与动态特性。&lt;/p&gt;&lt;/li&gt;
                &lt;/ul&gt;

                &lt;p&gt;&lt;a href=&quot;http://www.aiuxian.com/article/p-668098.html&quot;&gt;仿QQ空间登录，解决键盘挡住输入框的问题&lt;/a&gt;&lt;/p&gt;</column>
            <column name="image">NULL</column>
            <column name="featured">0</column>
            <column name="page">0</column>
            <column name="status">published</column>
            <column name="language">en_US</column>
            <column name="meta_title">NULL</column>
            <column name="meta_description">NULL</column>
            <column name="author_id">1</column>
            <column name="created_at">2015-03-23 15:32:10</column>
            <column name="created_by">1</column>
            <column name="updated_at">2015-04-01 15:31:41</column>
            <column name="updated_by">1</column>
            <column name="published_at">2015-03-23 15:32:25</column>
            <column name="published_by">1</column>
        </table>
        <table name="posts">
            <column name="id">10</column>
            <column name="uuid">55992425-0f2f-42ab-b14b-8aa6196488ec</column>
            <column name="title">Android 环形转动菜单学习笔记 1</column>
            <column name="slug">android-huan-xing-zhuan-dong-cai-dan-de-shi-xian</column>
            <column name="markdown">######学习资料来源： [鸿洋_的博客](http://blog.csdn.net/lmj623565791/article/details/43131133)

                &gt;前文

                很有幸能够看到这个作者的一系列Blog，对于对android自定义控件这块的学习有着巨大的帮助！如果看完他的Blog且自己动手实现，而且也还能够添加上自己新的想法，可以说你在自定义控件以及对于android的**[触摸事件的传递与处理](http://blog.csdn.net/lmj623565791/article/details/39102591)**,**[Canvas绘制](http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2012/1212/703.html)**,**[ViewGroup的构造](http://blog.csdn.net/lmj623565791/article/details/38339817)**这三个方面都会有一层全新的理解，而且更重要的是，如同博主在他的博文中提到的，如果掌握了这三点，你就可以打造出来你能够想到的任意的控件，而这点则是你从一个初级Android Developer走向中级乃至高级的必经之路。

                &gt;项目中涵盖的知识点

                - 1 ViewGroup的Measuer以及对其子控件的Measure以及Layout。
                - 2 TouchEvent的传递机制以及类型。
                - 3 简单的的三角函数。
                - 4 触摸事件结束后的**惯性运动**。

                &gt;首先，我们来根据项目的需求画出ViewGroup的草图

                这点对于开发一个自定义控件来说一定是最开始也是最关键的一步，只有画好了草图，并在脑海中模拟了控件运行的效果动画，才可以比较完善的总结出需要的变量以及需要在哪些地方使用android为我们提供的相关方法。

                &gt;根据草图实现自定义ViewGroup中的onMeasuer(),onLayout()方法
                ```
                @Override
                protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
                int measuredWidth = measure(widthMeasureSpec);
                int measuredHeight = measure(heightMeasureSpec);
                int d = Math.min(measuredWidth, measuredHeight);
                Log.e(&quot;D&quot;,&quot;&quot;+d);
                setMeasuredDimension(d, d);
                //  在这指定测量控件的大小 保持为一个正方形
                for(int i = 0 ; i &lt; getChildCount() ; i ++) {
                measureChild(getChildAt(i), widthMeasureSpec, heightMeasureSpec);
                }
                //  计算出中心在布局中的位置
                }

                private int measure(int measureSpec) {
                int result = 0;
                int specMode = MeasureSpec.getMode(measureSpec);
                int specSize = MeasureSpec.getSize(measureSpec);
                if (specMode == MeasureSpec.UNSPECIFIED) {
                //  如果没有限制大小则指定默认值为200
                result = 300;
                } else {
                result = specSize;
                }
                return result;
                }
                ```

                在onMeasuer()方法内部，首先我们需要一个正方形的ViewGroup则我们取出宽与高中较短的一个作为我们控件的尺寸，并且根据草图我们可以把我们的控件看做一个圆形，且根据我们的计算，圆的半径:

                ```
                radius = getMeasuredWidth() / 2;

                ```


                随后我们根据在构造函数中传入完毕的参数构造好相应的item，并添加至ViewGroup中，通过计算我们在onLayout()中对其一个一个的位置进行计算与放置。

                ```
                @Override
                protected void onLayout(boolean changed, int l, int t, int r, int b) {
                int width = getMeasuredWidth();
                int center = width/2;
                float degreeDivide = 360.0f / NUMBER;   //  每个item间隔的度数
                //  计算出item占得最大半径来圆心所在确定圆环最外的位置
                int maxSize = 0;
                for(int i = 0 ; i &lt; NUMBER ; i ++) {
                View v = getChildAt(i);
                int itemWidth = v.getMeasuredWidth();
                int itemHeight = v.getMeasuredHeight();
                //            int itemSize = (int)Math.ceil(Math.sqrt(2.0d) * Math.max(itemHeight, itemWidth));   //    计算出最大的圆半径
                int itemSize = Math.max(itemHeight, itemWidth);   //  根据长与宽的最大值确定
                if (itemHeight &gt; maxSize)
                maxSize = itemSize;
                }
                //  item圆心到ViewGroup圆心的距离
                int length = width/2 - maxSize/2;
                //  开始环形布局
                for(int i = 0 ; i &lt; NUMBER ; i ++) {
                View v = getChildAt(i);
                int itemWidth = v.getMeasuredWidth();
                int itemHeight = v.getMeasuredHeight();
                //	scrollAngle为滚动的角度 初始值为0
                float angle = (i*degreeDivide + scrollAngle)%360 ;
                int left = center + (int)Math.round(length * Math.cos(Math.toRadians(angle)) - itemWidth/2);
                int top = center + (int)Math.round(length * Math.sin(Math.toRadians(angle)) - itemHeight/2);
                ((TextView)v.findViewById(R.id.circle_menu_text)).setText(&quot;&quot;+i);
                v.layout(left, top, left + itemWidth, top + itemHeight);
                }
                }
                ```

                至此我们在将我们的控件添加至我们的布局中去，就可以看到一个呈环形分布的Item控件了。

                &gt;实现触摸滚动效果

                首先我们需要添加如下变量来帮助我们对触摸事件的处理，并帮助我们计算一次触摸过程中的平均角速度来计算出来是否需要进行惯性事件的处理。

                ```
                /* 用于记录上一次触摸位置的坐标 */
                private float mLastX;
                private float mLastY;
                /* 用于记录触摸开始时的时间 */
                private long timeStart;
                /* 用于记录一次触摸过程中的总共位移角度 */
                private int tempAngle;
                /* 实现了Runnable接口的class用于处理滑动后的惯性效果 */
                private AutoFlingRunnable autoFlingRunnable;
                /* 标志位 标志是否处于惯性滑动状态 */
                private boolean isFling = false;
                /* 常量 用于对惯性的状态的定义 */
                private static final float FLING_MINUS_VALUE = 300.0f;
                private static final float FLING_DECREASE_PER_SECOND = 10.0f;
                ```

                随后我们复写dispatchTouchEvent方法，根据捕捉相应的MotionEvent的Action进行处理：

                - 1 当用户开始触摸时，类型为 ACTION_DOWN

                - 1 此时我们记录下触摸开始时的时间  timeStart。
                - 2 以及触摸开始时的坐标 mLastX, mLastY。
                - 3 并且判断如果当前属于惯性滚动状态则直接停止。
                ```
                case MotionEvent.ACTION_DOWN:
                Log.e(&quot;TOUCH&quot;,&quot;DOWN&quot;);
                mLastX = x;
                mLastY = y;
                timeStart = System.currentTimeMillis();
                tempAngle = 0;
                //  如果正在滑动则停止
                if(isFling) {
                removeCallbacks(autoFlingRunnable);
                isFling = false;
                return true;
                }
                break;
                ```
                - 2 当用户手开始滑动时, 类型为 ACTION_MOVE

                - 1 首先根据上一次的位置计算出上一次的角度（与X轴夹角）。
                - 2 计算出本次位置的角度。
                - 3 根据象限来计算出两次角度的差值。
                - 4 将差值添加至临时变量并请求重新布局来实现滚动。
                ```
                case MotionEvent.ACTION_MOVE:
                Log.e(&quot;TOUCH&quot;,&quot;MOVE&quot;);
                //  触摸开始时候的角度
                float start = getAngle(mLastX, mLastY);
                //  现在位置的角度
                float now = getAngle(x, y);
                //  由于计算是根据y值与(x, y)到原点的相关计算 所以：如果现在位置位于1 4 象限 则角度为正 2 3 象限 则角度为负值
                int quadrant = getQuadrant(x, y);
                if(quadrant == 1 || quadrant == 4) {
                tempAngle += (now - start);
                scrollAngle += (now - start);
                }else{
                tempAngle += (start - now);
                scrollAngle += (start - now);
                }
                requestLayout();
                mLastX = x;
                mLastY = y;
                break;
                ```

                - 3 当用户手抬起，结束时, 类型为 ACTION_UP

                - 1 计算出这次触摸的平均角速度。
                - 2 根据角速度判断是否需要进行惯性滚动事件。
                ```
                case MotionEvent.ACTION_UP:
                //  计算角速度
                float anglePerSecond = tempAngle * 1000 / (timeStart - System.currentTimeMillis());
                if(Math.abs(anglePerSecond) &gt; FLING_MINUS_VALUE &amp;&amp; !isFling) {
                post(autoFlingRunnable = new AutoFlingRunnable(anglePerSecond));
                return true;
                }
                break;
                ```


                其中关于角度的计算方法，借用一下博主的原图:

                ![](http://img.blog.csdn.net/20150126015712660?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbG1qNjIzNTY1Nzkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)


                &gt;额外计划

                添加滚动监听 能够滚动至相应的‘卡槽’内并返回滚动的位置，实际上是整合了原博主的另一篇Blog关于[抽奖轮盘的实现](http://blog.csdn.net/lmj623565791/article/details/41722441)中的相关知识点。

                &gt;总结&amp;结尾

                还是跟感谢这位博主能够分享如此多的知识，在以后我这边也会慢慢学习原博主的一些项目源码~

            </column>
            <column name="html">&lt;h6 id=&quot;_httpblogcsdnnetlmj623565791articledetails43131133&quot;&gt;学习资料来源： &lt;a href=&quot;http://blog.csdn.net/lmj623565791/article/details/43131133&quot;&gt;鸿洋_的博客&lt;/a&gt;&lt;/h6&gt;

                &lt;blockquote&gt;
                &lt;p&gt;前文&lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;p&gt;很有幸能够看到这个作者的一系列Blog，对于对android自定义控件这块的学习有着巨大的帮助！如果看完他的Blog且自己动手实现，而且也还能够添加上自己新的想法，可以说你在自定义控件以及对于android的&lt;strong&gt;&lt;a href=&quot;http://blog.csdn.net/lmj623565791/article/details/39102591&quot;&gt;触摸事件的传递与处理&lt;/a&gt;&lt;/strong&gt;,&lt;strong&gt;&lt;a href=&quot;http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2012/1212/703.html&quot;&gt;Canvas绘制&lt;/a&gt;&lt;/strong&gt;,&lt;strong&gt;&lt;a href=&quot;http://blog.csdn.net/lmj623565791/article/details/38339817&quot;&gt;ViewGroup的构造&lt;/a&gt;&lt;/strong&gt;这三个方面都会有一层全新的理解，而且更重要的是，如同博主在他的博文中提到的，如果掌握了这三点，你就可以打造出来你能够想到的任意的控件，而这点则是你从一个初级Android Developer走向中级乃至高级的必经之路。&lt;/p&gt;

                &lt;blockquote&gt;
                &lt;p&gt;项目中涵盖的知识点&lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;ul&gt;
                &lt;li&gt;1 ViewGroup的Measuer以及对其子控件的Measure以及Layout。&lt;/li&gt;
                &lt;li&gt;2 TouchEvent的传递机制以及类型。&lt;/li&gt;
                &lt;li&gt;3 简单的的三角函数。&lt;/li&gt;
                &lt;li&gt;4 触摸事件结束后的&lt;strong&gt;惯性运动&lt;/strong&gt;。&lt;/li&gt;
                &lt;/ul&gt;

                &lt;blockquote&gt;
                &lt;p&gt;首先，我们来根据项目的需求画出ViewGroup的草图&lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;p&gt;这点对于开发一个自定义控件来说一定是最开始也是最关键的一步，只有画好了草图，并在脑海中模拟了控件运行的效果动画，才可以比较完善的总结出需要的变量以及需要在哪些地方使用android为我们提供的相关方法。&lt;/p&gt;

                &lt;blockquote&gt;
                &lt;p&gt;根据草图实现自定义ViewGroup中的onMeasuer(),onLayout()方法&lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;pre&gt;&lt;code&gt; @Override
                protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
                int measuredWidth = measure(widthMeasureSpec);
                int measuredHeight = measure(heightMeasureSpec);
                int d = Math.min(measuredWidth, measuredHeight);
                Log.e(&quot;D&quot;,&quot;&quot;+d);
                setMeasuredDimension(d, d);
                //  在这指定测量控件的大小 保持为一个正方形
                for(int i = 0 ; i &amp;lt; getChildCount() ; i ++) {
                measureChild(getChildAt(i), widthMeasureSpec, heightMeasureSpec);
                }
                //  计算出中心在布局中的位置
                }

                private int measure(int measureSpec) {
                int result = 0;
                int specMode = MeasureSpec.getMode(measureSpec);
                int specSize = MeasureSpec.getSize(measureSpec);
                if (specMode == MeasureSpec.UNSPECIFIED) {
                //  如果没有限制大小则指定默认值为200
                result = 300;
                } else {
                result = specSize;
                }
                return result;
                }
                &lt;/code&gt;&lt;/pre&gt;

                &lt;p&gt;在onMeasuer()方法内部，首先我们需要一个正方形的ViewGroup则我们取出宽与高中较短的一个作为我们控件的尺寸，并且根据草图我们可以把我们的控件看做一个圆形，且根据我们的计算，圆的半径:&lt;/p&gt;

                &lt;pre&gt;&lt;code&gt;radius = getMeasuredWidth() / 2;
                &lt;/code&gt;&lt;/pre&gt;

                &lt;p&gt;随后我们根据在构造函数中传入完毕的参数构造好相应的item，并添加至ViewGroup中，通过计算我们在onLayout()中对其一个一个的位置进行计算与放置。&lt;/p&gt;

                &lt;pre&gt;&lt;code&gt; @Override
                protected void onLayout(boolean changed, int l, int t, int r, int b) {
                int width = getMeasuredWidth();
                int center = width/2;
                float degreeDivide = 360.0f / NUMBER;   //  每个item间隔的度数
                //  计算出item占得最大半径来圆心所在确定圆环最外的位置
                int maxSize = 0;
                for(int i = 0 ; i &amp;lt; NUMBER ; i ++) {
                View v = getChildAt(i);
                int itemWidth = v.getMeasuredWidth();
                int itemHeight = v.getMeasuredHeight();
                //            int itemSize = (int)Math.ceil(Math.sqrt(2.0d) * Math.max(itemHeight, itemWidth));   //    计算出最大的圆半径
                int itemSize = Math.max(itemHeight, itemWidth);   //  根据长与宽的最大值确定
                if (itemHeight &amp;gt; maxSize)
                maxSize = itemSize;
                }
                //  item圆心到ViewGroup圆心的距离
                int length = width/2 - maxSize/2;
                //  开始环形布局
                for(int i = 0 ; i &amp;lt; NUMBER ; i ++) {
                View v = getChildAt(i);
                int itemWidth = v.getMeasuredWidth();
                int itemHeight = v.getMeasuredHeight();
                //    scrollAngle为滚动的角度 初始值为0
                float angle = (i*degreeDivide + scrollAngle)%360 ;
                int left = center + (int)Math.round(length * Math.cos(Math.toRadians(angle)) - itemWidth/2);
                int top = center + (int)Math.round(length * Math.sin(Math.toRadians(angle)) - itemHeight/2);
                ((TextView)v.findViewById(R.id.circle_menu_text)).setText(&quot;&quot;+i);
                v.layout(left, top, left + itemWidth, top + itemHeight);
                }
                }
                &lt;/code&gt;&lt;/pre&gt;

                &lt;p&gt;至此我们在将我们的控件添加至我们的布局中去，就可以看到一个呈环形分布的Item控件了。&lt;/p&gt;

                &lt;blockquote&gt;
                &lt;p&gt;实现触摸滚动效果&lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;p&gt;首先我们需要添加如下变量来帮助我们对触摸事件的处理，并帮助我们计算一次触摸过程中的平均角速度来计算出来是否需要进行惯性事件的处理。&lt;/p&gt;

                &lt;pre&gt;&lt;code&gt; /* 用于记录上一次触摸位置的坐标 */
                private float mLastX;
                private float mLastY;
                /* 用于记录触摸开始时的时间 */
                private long timeStart;
                /* 用于记录一次触摸过程中的总共位移角度 */
                private int tempAngle;
                /* 实现了Runnable接口的class用于处理滑动后的惯性效果 */
                private AutoFlingRunnable autoFlingRunnable;
                /* 标志位 标志是否处于惯性滑动状态 */
                private boolean isFling = false;
                /* 常量 用于对惯性的状态的定义 */
                private static final float FLING_MINUS_VALUE = 300.0f;
                private static final float FLING_DECREASE_PER_SECOND = 10.0f;
                &lt;/code&gt;&lt;/pre&gt;

                &lt;p&gt;随后我们复写dispatchTouchEvent方法，根据捕捉相应的MotionEvent的Action进行处理：&lt;/p&gt;

                &lt;ul&gt;
                &lt;li&gt;&lt;p&gt;1 当用户开始触摸时，类型为 ACTION_DOWN&lt;/p&gt;

                &lt;ul&gt;&lt;li&gt;1 此时我们记录下触摸开始时的时间  timeStart。 &lt;/li&gt;
                &lt;li&gt;2 以及触摸开始时的坐标 mLastX, mLastY。&lt;/li&gt;
                &lt;li&gt;3 并且判断如果当前属于惯性滚动状态则直接停止。
                &lt;code&gt;
                case MotionEvent.ACTION_DOWN:
                Log.e(&quot;TOUCH&quot;,&quot;DOWN&quot;);
                mLastX = x;
                mLastY = y;
                timeStart = System.currentTimeMillis();
                tempAngle = 0;
                //  如果正在滑动则停止
                if(isFling) {
                removeCallbacks(autoFlingRunnable);
                isFling = false;
                return true;
                }
                break;
                &lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
                &lt;li&gt;&lt;p&gt;2 当用户手开始滑动时, 类型为 ACTION_MOVE&lt;/p&gt;

                &lt;ul&gt;&lt;li&gt;1 首先根据上一次的位置计算出上一次的角度（与X轴夹角）。&lt;/li&gt;
                &lt;li&gt;2 计算出本次位置的角度。&lt;/li&gt;
                &lt;li&gt;3 根据象限来计算出两次角度的差值。&lt;/li&gt;
                &lt;li&gt;4 将差值添加至临时变量并请求重新布局来实现滚动。
                &lt;code&gt;
                case MotionEvent.ACTION_MOVE:
                Log.e(&quot;TOUCH&quot;,&quot;MOVE&quot;);
                //  触摸开始时候的角度
                float start = getAngle(mLastX, mLastY);
                //  现在位置的角度
                float now = getAngle(x, y);
                //  由于计算是根据y值与(x, y)到原点的相关计算 所以：如果现在位置位于1 4 象限 则角度为正 2 3 象限 则角度为负值
                int quadrant = getQuadrant(x, y);
                if(quadrant == 1 || quadrant == 4) {
                tempAngle += (now - start);
                scrollAngle += (now - start);
                }else{
                tempAngle += (start - now);
                scrollAngle += (start - now);
                }
                requestLayout();
                mLastX = x;
                mLastY = y;
                break;
                &lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
                &lt;li&gt;&lt;p&gt;3 当用户手抬起，结束时, 类型为 ACTION_UP&lt;/p&gt;

                &lt;ul&gt;&lt;li&gt;1 计算出这次触摸的平均角速度。&lt;/li&gt;
                &lt;li&gt;2 根据角速度判断是否需要进行惯性滚动事件。
                &lt;code&gt;
                case MotionEvent.ACTION_UP:
                //  计算角速度
                float anglePerSecond = tempAngle * 1000 / (timeStart - System.currentTimeMillis());
                if(Math.abs(anglePerSecond) &amp;gt; FLING_MINUS_VALUE &amp;amp;&amp;amp; !isFling) {
                post(autoFlingRunnable = new AutoFlingRunnable(anglePerSecond));
                return true;
                }
                break;
                &lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;

                &lt;p&gt;其中关于角度的计算方法，借用一下博主的原图:&lt;/p&gt;

                &lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20150126015712660?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbG1qNjIzNTY1Nzkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;&quot; title=&quot;&quot; /&gt;&lt;/p&gt;&lt;/li&gt;
                &lt;/ul&gt;

                &lt;blockquote&gt;
                &lt;p&gt;额外计划&lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;p&gt;添加滚动监听 能够滚动至相应的‘卡槽’内并返回滚动的位置，实际上是整合了原博主的另一篇Blog关于&lt;a href=&quot;http://blog.csdn.net/lmj623565791/article/details/41722441&quot;&gt;抽奖轮盘的实现&lt;/a&gt;中的相关知识点。&lt;/p&gt;

                &lt;blockquote&gt;
                &lt;p&gt;总结&amp;amp;结尾&lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;p&gt;还是跟感谢这位博主能够分享如此多的知识，在以后我这边也会慢慢学习原博主的一些项目源码~&lt;/p&gt;</column>
            <column name="image">NULL</column>
            <column name="featured">0</column>
            <column name="page">0</column>
            <column name="status">published</column>
            <column name="language">en_US</column>
            <column name="meta_title">NULL</column>
            <column name="meta_description">NULL</column>
            <column name="author_id">1</column>
            <column name="created_at">2015-03-23 15:33:11</column>
            <column name="created_by">1</column>
            <column name="updated_at">2015-04-08 10:24:08</column>
            <column name="updated_by">1</column>
            <column name="published_at">2015-03-23 15:33:16</column>
            <column name="published_by">1</column>
        </table>
        <table name="posts">
            <column name="id">11</column>
            <column name="uuid">9a11dbeb-a4e5-42af-a642-72b146799255</column>
            <column name="title">[笔记]Android Bitmap的优化控制</column>
            <column name="slug">bi-ji-android-bitmapde-you-hua-kong-zhi</column>
            <column name="markdown">[android客户端的bitmap复用](http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0305/2538.html)</column>
            <column name="html">&lt;p&gt;&lt;a href=&quot;http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0305/2538.html&quot;&gt;android客户端的bitmap复用&lt;/a&gt;&lt;/p&gt;</column>
            <column name="image">NULL</column>
            <column name="featured">0</column>
            <column name="page">0</column>
            <column name="status">published</column>
            <column name="language">en_US</column>
            <column name="meta_title">NULL</column>
            <column name="meta_description">NULL</column>
            <column name="author_id">1</column>
            <column name="created_at">2015-03-24 15:41:01</column>
            <column name="created_by">1</column>
            <column name="updated_at">2015-03-24 15:41:25</column>
            <column name="updated_by">1</column>
            <column name="published_at">2015-03-24 15:41:25</column>
            <column name="published_by">1</column>
        </table>
        <table name="posts">
            <column name="id">12</column>
            <column name="uuid">45a7d3f3-9c4b-467b-a319-ee01e70518aa</column>
            <column name="title">Android 提示框控件 ShowTipsView 的源码分析</column>
            <column name="slug">android-ti-shi-kuang-zi-ding-yi-kong-jian-hinthelperde-kai-fa</column>
            <column name="markdown">![](http://i2.tietuku.com/d1fb2dec2dce609f.png)
                [ShowTipsView](https://github.com/fredericojssilva/ShowTipsView)是近日看到的一款比较好的提示类的第三方控件库，在看了源码之后发现对于我们理解Android的Canvas的具体用法以及Activity是如何加载我们定义好的Layout布局文件有着很好的启示作用，所以就拿来一起学习，一起分析~

                &gt;onCreate中setContentView方法做了什么

                从开始写第一个Android程序我们就会用到这个方法，他总是躺在super.onCreate(...)的下方，一开始我只知道就是制定加载的布局文件，那么实际上它到底做了什么呢？

                我们就来看一看源码(Android API21)：

                ```
                //	首先ctrl+B找到源码 发现调用了 getWindow()方法
                public void setContentView(int layoutResID) {
                getWindow().setContentView(layoutResID);
                initWindowDecorActionBar();
                }

                //	再找到getWindow() 发现实际上是调用的一个Window对象的setContentView方法
                public Window getWindow() {
                return mWindow;
                }

                //	再找到Window类 发现是一个抽象类 那么这个Window的对象mWindow一定是又某个具体类实例化 我们再继续寻找
                //	依然在Activity类内部的 attach(....) 内部寻找到了它

                mWindow = PolicyManager.makeNewWindow(this);
                mWindow.setCallback(this);
                ........

                //	那么继续寻找
                public static Window makeNewWindow(Context context) {
                // this will likely crash somewhere beyond so we log it.
                Bridge.getLog().error(LayoutLog.TAG_UNSUPPORTED,
                &quot;Call to PolicyManager.makeNewWindow is not supported&quot;, null);
                return null;
                }
                ```

                ######我了个大曹！
                &lt;BR/&gt;
                你没看错，我找到这的时候，的确懵逼了...

                于是我就去尝试搜索一下大家对于这个情况的相关情况，发现在其他人的PolicyManager里面是要比我找到的要多好多行代码的，目前考虑到是API21上做了某些修改，把一些代码隐藏掉？（待研究）

                不过还是看看其他人对这个的解释吧，感觉说的比较好的有两篇文章，这里分享给大家
                [这篇确实没有找到相关的作者](http://www.xuebuyuan.com/1631537.html) 以及
                [罗升阳的博客](http://blog.csdn.net/luoshengyang/article/details/8223770)

                大概讲的意思如下：这个类只是一个对Policy类的包装，Policy类位于\sources\android-21\com\android\internal\policy\impl下，其中一些较复杂的知识点我也是一知半解，但是我们还是来看看这个类吧。

                ```
                public Window makeNewWindow(Context context) {
                return new PhoneWindow(context);
                }
                ```

                首先在类中的static静态代码块中执行了Class.forName()方法（_这个方法应该很多接触过JDBC的同学应该不会陌生_）将一系列的class进行加载，然后又引入了一个新的概念
                __PhoneWindow__
                天啦撸...感觉怎么就一发不可收拾了....

                好吧我们继续~

                发现PhonwWindow是Window的子类，那么直奔setContentView()方法
                ```
                public void setContentView(int layoutResID) {
                if (mContentParent == null) {
                installDecor();
                } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) {
                mContentParent.removeAllViews();
                }

                if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) {
                final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,
                getContext());
                transitionTo(newScene);
                } else {
                mLayoutInflater.inflate(layoutResID, mContentParent);
                }
                final Callback cb = getCallback();
                if (cb != null &amp;&amp; !isDestroyed()) {
                cb.onContentChanged();
                }
                }
                ```

                这段代码大概是执行了如下的操作：

                - 1 首先判断mContentParent是否为空，如果为空则调用installDecor()方法，调用这个方法就会生成一个decor，这个decor就是你整个应用的最大的最底层的RootView。如果不为空，则说明你的应用已经有这个底层ViewGroup那么既然要放置新的Layout就必须移除掉里面的东西，就会调用removeAllViews()方法。

                值得注意的是很多同学肯定遇到过在代码内部设置你的Activity是否为全屏，是否含有标题栏，之前都是必须要将代码写在setContentView()上，就是因为在installDecor()方法内部会根据参数来生成指定的RootView。

                - 2 DecorView内部会包含一个mContentParent的FrameLayout，随后调用我们常用的LayoutInflater将我们的布局加载并放入到这个FrameLayout中去。

                借用一下上文Blog中的图片
                ![DecorView](http://note.youdao.com/yws/public/resource/90e82889e770611f5349dfe52e32907c/734583BD866B4E4CA31EE64B0F4D764F)

                - 3 至此我们的布局加载完毕。

                虽然关于Activity的创建以及布局的加载还有很多地方不明白，但也会在以后逐渐了解的路上慢慢记录下来，与大家分享~

                &gt;回到正题，我们来看项目的源码

                先看到我们主要使用的ShowTipsView是继承自RelativeLayout的自定义ViewGroup。

                那么根据Github上提示的使用方法，我们直接跳到ShowTipsView的show()方法中

                ```
                if (isDisplayOneTime() &amp;&amp; showTipsStore.hasShown(getDisplayOneTimeID())) {
                setVisibility(View.GONE);			    ((ViewGroup((Activity)getContext()).getWindow().getDecorView()).removeView(ShowTipsView.this);
                return;
                } else {
                if (isDisplayOneTime())
                showTipsStore.storeShownId(getDisplayOneTimeID());
                }
                ......暂时到这
                ```

                - 1 首先，会进行判断，如果能够显示的已经显示完毕，即不需要在显示，那么首先隐藏掉自己，然后把自己从刚才我们讲的DecorView中移除。
                - 2 然后在进行一些SharedPreference上的标记处理，保证Hint不会多次出现

                接下来就是比较重要的部分

                ```
                new Handler().postDelayed(new Runnable() {
                @Override
                public void run() {
                ((ViewGroup) activity.getWindow().getDecorView()).addView(ShowTipsView.this);
                ShowTipsView.this.setVisibility(View.VISIBLE);
                Animation fadeInAnimation = AnimationUtils.loadAnimation(getContext(), R.anim.fade_in);
                ShowTipsView.this.startAnimation(fadeInAnimation);
                final ViewTreeObserver observer = targetView.getViewTreeObserver();
                observer.addOnGlobalLayoutListener(new OnGlobalLayoutListener() {
                @Override
                public void onGlobalLayout() {
                if (isMeasured)
                return;
                if (targetView.getHeight() &gt; 0 &amp;&amp; targetView.getWidth() &gt; 0) {
                isMeasured = true;
                }
                if (custom == false) {
                int[] location = new int[2];
                targetView.getLocationInWindow(location);
                int x = location[0] + targetView.getWidth() / 2;
                int y = location[1] + targetView.getHeight() / 2;
                // Log.d(&quot;FRED&quot;, &quot;X:&quot; + x + &quot; Y: &quot; + y);
                Point p = new Point(x, y);
                showhintPoints = p;
                radius = targetView.getWidth() / 2;
                } else {
                int[] location = new int[2];
                targetView.getLocationInWindow(location);
                int x = location[0] + showhintPoints.x;
                int y = location[1] + showhintPoints.y;
                // Log.d(&quot;FRED&quot;, &quot;X:&quot; + x + &quot; Y: &quot; + y);
                Point p = new Point(x, y);
                showhintPoints = p;
                }
                invalidate();
                createViews();
                }
                });
                }
                }, getDelay());
                ```

                说是话并不喜欢在文章里面加上大段的代码，因为让人毫无看下去的兴趣，那么我们还是来一段一段看吧。

                - 1 首先在UI线程内部post一个Runnable消息，并添加延迟来更新UI。
                - 2 接下来把自己本身加载到DecorView中去，就好比添加了一个覆盖层，完美的覆盖到了你的应用上面。
                - 3 设置自身为可见并调用渐现动画。

                上面的相信大家一看就能明白，再往下就是比较重要的部分了。


                - 1 首先根据我们需要显示的targetView，获取他的ViewTreeObserver对象
                ```
                final ViewTreeObserver observer = targetView.getViewTreeObserver();
                ```
                关于这个ViewTreeObserver其实我们只要知道它只是负责对当前的持有View进行一些监听与回调，而在这使用这个主要是为了在确保TargetView正确渲染完毕之后再进行一些计算，比如我们常常遇到的getWidth()返回0就是因为View还未渲染完毕（参见我的Blog中关于onLayout, onMeasure View绘制过程的博文）。

                - 2 在获取到TargetView的ViewTreeObserver后，我们添加自己的回调函数接口，OnGlobalLayoutListener，这个Listener在源码的注释中介绍的比较详细，而且本身也只有一个回调函数onGlobalLayout()。不过当这个接口函数被调用的时候，我们就可以在里面进行对targetView尺寸的计算。

                - 3 根据计算的宽和高我们可以计算出覆盖这个的圆心以及圆的半径。然后根据提供的信息绘制出一个我们计算出来的圆的补集，再加上文字与按钮，OK！大功告成！

                基本上核心源码已经一起看的差不多了，那么接下来就是看一看如何绘制出图中控件的效果的！

                &gt;开始绘制我们的Tips界面

                - 1 首先我们要绘制一个半透明但是目标区域透明的背景图，就是很简单的Paint使用。
                - 2 接下来用“橡皮擦”绘制出中间我们计算好的透明圆。
                这里会用到Paint的Xfermode，关于这点不清楚的请转到[Blog](http://blog.csdn.net/t12x3456/article/details/10432935)查看，顺手贴一张图吧
                ![](http://img.blog.csdn.net/20130828212947609?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdDEyeDM0NTY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
                我们将新的Paint设置为CLEAR，随后根据计算好的圆心以及半径就可以画出需要的效果了。
                - 3 最后添加上一些需要的提示文字以及按钮即可。

                &gt;值得学习的设计思路

                - 1 首先，采用Observer的方式，可以满足用户界面的种种变换，例如屏幕大小改变，屏幕翻转，等等条件，随后在回调中重新计算半径与圆心并绘制出图案，这种设计模式完美针对了所有情况，使得这个TipsView在任意条件下都能够完美的出现在正确的地方！


            </column>
            <column name="html">&lt;p&gt;&lt;img src=&quot;http://i2.tietuku.com/d1fb2dec2dce609f.png&quot; alt=&quot;&quot; /&gt;
                &lt;a href=&quot;https://github.com/fredericojssilva/ShowTipsView&quot;&gt;ShowTipsView&lt;/a&gt;是近日看到的一款比较好的提示类的第三方控件库，在看了源码之后发现对于我们理解Android的Canvas的具体用法以及Activity是如何加载我们定义好的Layout布局文件有着很好的启示作用，所以就拿来一起学习，一起分析~&lt;/p&gt;

                &lt;blockquote&gt;
                &lt;p&gt;onCreate中setContentView方法做了什么&lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;p&gt;从开始写第一个Android程序我们就会用到这个方法，他总是躺在super.onCreate(...)的下方，一开始我只知道就是制定加载的布局文件，那么实际上它到底做了什么呢？&lt;/p&gt;

                &lt;p&gt;我们就来看一看源码(Android API21)：&lt;/p&gt;

                &lt;pre&gt;&lt;code&gt;    //  首先ctrl+B找到源码 发现调用了 getWindow()方法
                public void setContentView(int layoutResID) {
                getWindow().setContentView(layoutResID);
                initWindowDecorActionBar();
                }

                //    再找到getWindow() 发现实际上是调用的一个Window对象的setContentView方法
                public Window getWindow() {
                return mWindow;
                }

                //    再找到Window类 发现是一个抽象类 那么这个Window的对象mWindow一定是又某个具体类实例化 我们再继续寻找
                //    依然在Activity类内部的 attach(....) 内部寻找到了它

                mWindow = PolicyManager.makeNewWindow(this);
                mWindow.setCallback(this);
                ........

                //    那么继续寻找
                public static Window makeNewWindow(Context context) {
                // this will likely crash somewhere beyond so we log it.
                Bridge.getLog().error(LayoutLog.TAG_UNSUPPORTED,
                &quot;Call to PolicyManager.makeNewWindow is not supported&quot;, null);
                return null;
                }
                &lt;/code&gt;&lt;/pre&gt;

                &lt;h6 id=&quot;&quot;&gt;我了个大曹！&lt;/h6&gt;

                &lt;p&gt;&lt;BR/&gt; &lt;br /&gt;
                你没看错，我找到这的时候，的确懵逼了...&lt;/p&gt;

                &lt;p&gt;于是我就去尝试搜索一下大家对于这个情况的相关情况，发现在其他人的PolicyManager里面是要比我找到的要多好多行代码的，目前考虑到是API21上做了某些修改，把一些代码隐藏掉？（待研究）&lt;/p&gt;

                &lt;p&gt;不过还是看看其他人对这个的解释吧，感觉说的比较好的有两篇文章，这里分享给大家
                &lt;a href=&quot;http://www.xuebuyuan.com/1631537.html&quot;&gt;这篇确实没有找到相关的作者&lt;/a&gt; 以及
                &lt;a href=&quot;http://blog.csdn.net/luoshengyang/article/details/8223770&quot;&gt;罗升阳的博客&lt;/a&gt;&lt;/p&gt;

                &lt;p&gt;大概讲的意思如下：这个类只是一个对Policy类的包装，Policy类位于\sources\android-21\com\android\internal\policy\impl下，其中一些较复杂的知识点我也是一知半解，但是我们还是来看看这个类吧。&lt;/p&gt;

                &lt;pre&gt;&lt;code&gt;public Window makeNewWindow(Context context) {
                return new PhoneWindow(context);
                }
                &lt;/code&gt;&lt;/pre&gt;

                &lt;p&gt;首先在类中的static静态代码块中执行了Class.forName()方法（&lt;em&gt;这个方法应该很多接触过JDBC的同学应该不会陌生&lt;/em&gt;）将一系列的class进行加载，然后又引入了一个新的概念
                &lt;strong&gt;PhoneWindow&lt;/strong&gt; &lt;br /&gt;
                天啦撸...感觉怎么就一发不可收拾了....&lt;/p&gt;

                &lt;p&gt;好吧我们继续~&lt;/p&gt;

                &lt;p&gt;发现PhonwWindow是Window的子类，那么直奔setContentView()方法&lt;/p&gt;

                &lt;pre&gt;&lt;code&gt;public void setContentView(int layoutResID) {
                if (mContentParent == null) {
                installDecor();
                } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) {
                mContentParent.removeAllViews();
                }

                if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) {
                final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,
                getContext());
                transitionTo(newScene);
                } else {
                mLayoutInflater.inflate(layoutResID, mContentParent);
                }
                final Callback cb = getCallback();
                if (cb != null &amp;amp;&amp;amp; !isDestroyed()) {
                cb.onContentChanged();
                }
                }
                &lt;/code&gt;&lt;/pre&gt;

                &lt;p&gt;这段代码大概是执行了如下的操作：&lt;/p&gt;

                &lt;ul&gt;
                &lt;li&gt;&lt;p&gt;1 首先判断mContentParent是否为空，如果为空则调用installDecor()方法，调用这个方法就会生成一个decor，这个decor就是你整个应用的最大的最底层的RootView。如果不为空，则说明你的应用已经有这个底层ViewGroup那么既然要放置新的Layout就必须移除掉里面的东西，就会调用removeAllViews()方法。&lt;/p&gt;

                &lt;p&gt;值得注意的是很多同学肯定遇到过在代码内部设置你的Activity是否为全屏，是否含有标题栏，之前都是必须要将代码写在setContentView()上，就是因为在installDecor()方法内部会根据参数来生成指定的RootView。&lt;/p&gt;&lt;/li&gt;
                &lt;li&gt;&lt;p&gt;2 DecorView内部会包含一个mContentParent的FrameLayout，随后调用我们常用的LayoutInflater将我们的布局加载并放入到这个FrameLayout中去。&lt;/p&gt;

                &lt;p&gt;借用一下上文Blog中的图片
                &lt;img src=&quot;http://note.youdao.com/yws/public/resource/90e82889e770611f5349dfe52e32907c/734583BD866B4E4CA31EE64B0F4D764F&quot; alt=&quot;DecorView&quot; title=&quot;&quot; /&gt;&lt;/p&gt;&lt;/li&gt;
                &lt;li&gt;&lt;p&gt;3 至此我们的布局加载完毕。&lt;/p&gt;&lt;/li&gt;
                &lt;/ul&gt;

                &lt;p&gt;虽然关于Activity的创建以及布局的加载还有很多地方不明白，但也会在以后逐渐了解的路上慢慢记录下来，与大家分享~&lt;/p&gt;

                &lt;blockquote&gt;
                &lt;p&gt;回到正题，我们来看项目的源码&lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;p&gt;先看到我们主要使用的ShowTipsView是继承自RelativeLayout的自定义ViewGroup。&lt;/p&gt;

                &lt;p&gt;那么根据Github上提示的使用方法，我们直接跳到ShowTipsView的show()方法中&lt;/p&gt;

                &lt;pre&gt;&lt;code&gt;if (isDisplayOneTime() &amp;amp;&amp;amp; showTipsStore.hasShown(getDisplayOneTimeID())) {
                setVisibility(View.GONE);               ((ViewGroup((Activity)getContext()).getWindow().getDecorView()).removeView(ShowTipsView.this);
                return;
                } else {
                if (isDisplayOneTime())
                showTipsStore.storeShownId(getDisplayOneTimeID());
                }
                ......暂时到这
                &lt;/code&gt;&lt;/pre&gt;

                &lt;ul&gt;
                &lt;li&gt;1 首先，会进行判断，如果能够显示的已经显示完毕，即不需要在显示，那么首先隐藏掉自己，然后把自己从刚才我们讲的DecorView中移除。&lt;/li&gt;
                &lt;li&gt;2 然后在进行一些SharedPreference上的标记处理，保证Hint不会多次出现&lt;/li&gt;
                &lt;/ul&gt;

                &lt;p&gt;接下来就是比较重要的部分&lt;/p&gt;

                &lt;pre&gt;&lt;code&gt;new Handler().postDelayed(new Runnable() {
                @Override
                public void run() {
                ((ViewGroup) activity.getWindow().getDecorView()).addView(ShowTipsView.this);
                ShowTipsView.this.setVisibility(View.VISIBLE);
                Animation fadeInAnimation = AnimationUtils.loadAnimation(getContext(), R.anim.fade_in);
                ShowTipsView.this.startAnimation(fadeInAnimation);
                final ViewTreeObserver observer = targetView.getViewTreeObserver();
                observer.addOnGlobalLayoutListener(new OnGlobalLayoutListener() {
                @Override
                public void onGlobalLayout() {
                if (isMeasured)
                return;
                if (targetView.getHeight() &amp;gt; 0 &amp;amp;&amp;amp; targetView.getWidth() &amp;gt; 0) {
                isMeasured = true;
                }
                if (custom == false) {
                int[] location = new int[2];
                targetView.getLocationInWindow(location);
                int x = location[0] + targetView.getWidth() / 2;
                int y = location[1] + targetView.getHeight() / 2;
                // Log.d(&quot;FRED&quot;, &quot;X:&quot; + x + &quot; Y: &quot; + y);
                Point p = new Point(x, y);
                showhintPoints = p;
                radius = targetView.getWidth() / 2;
                } else {
                int[] location = new int[2];
                targetView.getLocationInWindow(location);
                int x = location[0] + showhintPoints.x;
                int y = location[1] + showhintPoints.y;
                // Log.d(&quot;FRED&quot;, &quot;X:&quot; + x + &quot; Y: &quot; + y);
                Point p = new Point(x, y);
                showhintPoints = p;
                }
                invalidate();
                createViews();
                }
                });
                }
                }, getDelay());
                &lt;/code&gt;&lt;/pre&gt;

                &lt;p&gt;说是话并不喜欢在文章里面加上大段的代码，因为让人毫无看下去的兴趣，那么我们还是来一段一段看吧。&lt;/p&gt;

                &lt;ul&gt;
                &lt;li&gt;1 首先在UI线程内部post一个Runnable消息，并添加延迟来更新UI。&lt;/li&gt;
                &lt;li&gt;2 接下来把自己本身加载到DecorView中去，就好比添加了一个覆盖层，完美的覆盖到了你的应用上面。&lt;/li&gt;
                &lt;li&gt;3 设置自身为可见并调用渐现动画。&lt;/li&gt;
                &lt;/ul&gt;

                &lt;p&gt;上面的相信大家一看就能明白，再往下就是比较重要的部分了。&lt;/p&gt;

                &lt;ul&gt;
                &lt;li&gt;1 首先根据我们需要显示的targetView，获取他的ViewTreeObserver对象&lt;/li&gt;
                &lt;/ul&gt;

                &lt;pre&gt;&lt;code&gt;        final ViewTreeObserver observer = targetView.getViewTreeObserver();
                &lt;/code&gt;&lt;/pre&gt;

                &lt;p&gt;关于这个ViewTreeObserver其实我们只要知道它只是负责对当前的持有View进行一些监听与回调，而在这使用这个主要是为了在确保TargetView正确渲染完毕之后再进行一些计算，比如我们常常遇到的getWidth()返回0就是因为View还未渲染完毕（参见我的Blog中关于onLayout, onMeasure View绘制过程的博文）。&lt;/p&gt;

                &lt;ul&gt;
                &lt;li&gt;&lt;p&gt;2 在获取到TargetView的ViewTreeObserver后，我们添加自己的回调函数接口，OnGlobalLayoutListener，这个Listener在源码的注释中介绍的比较详细，而且本身也只有一个回调函数onGlobalLayout()。不过当这个接口函数被调用的时候，我们就可以在里面进行对targetView尺寸的计算。&lt;/p&gt;&lt;/li&gt;
                &lt;li&gt;&lt;p&gt;3 根据计算的宽和高我们可以计算出覆盖这个的圆心以及圆的半径。然后根据提供的信息绘制出一个我们计算出来的圆的补集，再加上文字与按钮，OK！大功告成！&lt;/p&gt;&lt;/li&gt;
                &lt;/ul&gt;

                &lt;p&gt;基本上核心源码已经一起看的差不多了，那么接下来就是看一看如何绘制出图中控件的效果的！&lt;/p&gt;

                &lt;blockquote&gt;
                &lt;p&gt;开始绘制我们的Tips界面&lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;ul&gt;
                &lt;li&gt;1 首先我们要绘制一个半透明但是目标区域透明的背景图，就是很简单的Paint使用。&lt;/li&gt;
                &lt;li&gt;2 接下来用“橡皮擦”绘制出中间我们计算好的透明圆。
                这里会用到Paint的Xfermode，关于这点不清楚的请转到&lt;a href=&quot;http://blog.csdn.net/t12x3456/article/details/10432935&quot;&gt;Blog&lt;/a&gt;查看，顺手贴一张图吧
                &lt;img src=&quot;http://img.blog.csdn.net/20130828212947609?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdDEyeDM0NTY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;&quot; /&gt;
                我们将新的Paint设置为CLEAR，随后根据计算好的圆心以及半径就可以画出需要的效果了。&lt;/li&gt;
                &lt;li&gt;3 最后添加上一些需要的提示文字以及按钮即可。&lt;/li&gt;
                &lt;/ul&gt;

                &lt;blockquote&gt;
                &lt;p&gt;值得学习的设计思路&lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;ul&gt;
                &lt;li&gt;1 首先，采用Observer的方式，可以满足用户界面的种种变换，例如屏幕大小改变，屏幕翻转，等等条件，随后在回调中重新计算半径与圆心并绘制出图案，这种设计模式完美针对了所有情况，使得这个TipsView在任意条件下都能够完美的出现在正确的地方！&lt;/li&gt;
                &lt;/ul&gt;</column>
            <column name="image">NULL</column>
            <column name="featured">0</column>
            <column name="page">0</column>
            <column name="status">published</column>
            <column name="language">en_US</column>
            <column name="meta_title">NULL</column>
            <column name="meta_description">NULL</column>
            <column name="author_id">1</column>
            <column name="created_at">2015-03-24 15:44:10</column>
            <column name="created_by">1</column>
            <column name="updated_at">2015-04-02 16:29:01</column>
            <column name="updated_by">1</column>
            <column name="published_at">2015-04-02 15:16:42</column>
            <column name="published_by">1</column>
        </table>
        <table name="posts">
            <column name="id">13</column>
            <column name="uuid">bfd1f12e-adad-4556-b7d5-133a6138c8bd</column>
            <column name="title">Android 使用style 与 ? 实现切换主题的效果</column>
            <column name="slug">android-shi-yong-style-yu-shi-xian-qie-huan-zhu-ti-de-xiao-guo</column>
            <column name="markdown">[Blog](http://blog.csdn.net/brokge/article/details/41247965)

                Application 与 Activity 在调用 onConfigurationChanged时Android具体做了什么</column>
            <column name="html">&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/brokge/article/details/41247965&quot;&gt;Blog&lt;/a&gt;&lt;/p&gt;

                &lt;p&gt;Application 与 Activity 在调用 onConfigurationChanged时Android具体做了什么&lt;/p&gt;</column>
            <column name="image">NULL</column>
            <column name="featured">0</column>
            <column name="page">0</column>
            <column name="status">draft</column>
            <column name="language">en_US</column>
            <column name="meta_title">NULL</column>
            <column name="meta_description">NULL</column>
            <column name="author_id">1</column>
            <column name="created_at">2015-03-25 12:35:44</column>
            <column name="created_by">1</column>
            <column name="updated_at">2015-03-25 12:49:39</column>
            <column name="updated_by">1</column>
            <column name="published_at">NULL</column>
            <column name="published_by">NULL</column>
        </table>
        <table name="posts">
            <column name="id">14</column>
            <column name="uuid">b28c8239-d029-4c6a-9391-e94630295325</column>
            <column name="title">NDK 中使用SOCKET</column>
            <column name="slug">ndk-zhong-shi-yong-socket</column>
            <column name="markdown">[BLog](http://blog.csdn.net/tody_guo/article/details/8196964)

                [实战例子](http://blog.csdn.net/hai836045106/article/details/40304147)</column>
            <column name="html">&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/tody_guo/article/details/8196964&quot;&gt;BLog&lt;/a&gt;&lt;/p&gt;

                &lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/hai836045106/article/details/40304147&quot;&gt;实战例子&lt;/a&gt;&lt;/p&gt;</column>
            <column name="image">NULL</column>
            <column name="featured">0</column>
            <column name="page">0</column>
            <column name="status">draft</column>
            <column name="language">en_US</column>
            <column name="meta_title">NULL</column>
            <column name="meta_description">NULL</column>
            <column name="author_id">1</column>
            <column name="created_at">2015-03-25 14:32:43</column>
            <column name="created_by">1</column>
            <column name="updated_at">2015-03-25 14:33:53</column>
            <column name="updated_by">1</column>
            <column name="published_at">NULL</column>
            <column name="published_by">NULL</column>
        </table>
        <table name="posts">
            <column name="id">15</column>
            <column name="uuid">858b00c6-1808-416d-a684-8b8edb9442c3</column>
            <column name="title">Android 中的辅助功能</column>
            <column name="slug">android-zhong-de-fu-zhu-gong-neng</column>
            <column name="markdown">[安卓中辅助功能的开发](http://www.xuebuyuan.com/2061597.html)</column>
            <column name="html">&lt;p&gt;&lt;a href=&quot;http://www.xuebuyuan.com/2061597.html&quot;&gt;安卓中辅助功能的开发&lt;/a&gt;&lt;/p&gt;</column>
            <column name="image">NULL</column>
            <column name="featured">0</column>
            <column name="page">0</column>
            <column name="status">draft</column>
            <column name="language">en_US</column>
            <column name="meta_title">NULL</column>
            <column name="meta_description">NULL</column>
            <column name="author_id">1</column>
            <column name="created_at">2015-03-26 08:25:07</column>
            <column name="created_by">1</column>
            <column name="updated_at">2015-03-26 08:25:36</column>
            <column name="updated_by">1</column>
            <column name="published_at">NULL</column>
            <column name="published_by">NULL</column>
        </table>
        <table name="posts">
            <column name="id">16</column>
            <column name="uuid">c16c2811-075b-4f0a-b883-578e5105774b</column>
            <column name="title">Android 推送分享等功能基于SDK的开发学习（一）</column>
            <column name="slug">android-tui-song-fen-xiang-gong-neng-ji-yu-sdkde-kai-fa-xue-xi</column>
            <column name="markdown">&gt;关于推送的学习-百度云推送

                由于之前的相关SDK一直采用百度的，虽然感觉百度的经常被大家诟病，但是[相关的文档](http://push.baidu.com/doc/android/api)应该是算相当完善与贴近我这种新手的，下面就说一下对百度云推送的使用小经验~


                ######要使用百度云推送，首先要进行下面几个步骤:

                - 1 &lt;del&gt;注册成为百度开发者.
                - 2 前往网站下载相关的[SDK](http://push.baidu.com/download).
                - 3 [申请](http://push.baidu.com/console/app/list)你需要的 API KEY, 并把你的项目的包名添加进去.
                - 4 将SDK中的jar, so文件引入项目中的正确位置.
                - 5 在Manifest.xml中申请推送所需要的权限.
                - 6 同样在Manifest.xml中注册相关的推送服务的百度Service, 百度的Receiver,富文本读取用的Activity(可选).
                - 7 如果你实现了自己的Appilcation, 那么你可以将你的Application继承自FrontiaApplication,或者是在onCreate()方法中调用```FrontiaApplication.initFrontia(Context context)``` 如果没有则你需要在指定Application标签的name属性为```&quot;com.baidu.frontia.FrontiaApplication&quot;.```
                - 8 实现自己的处理推送的Receiver并继承FrontiaPushMessageReceiver, 并实现其中的相应接口函数.
                - 9 利用PushManager.startWork(getApplicationContext(),
                PushConstants.LOGIN_TYPE_API_KEY,
                &quot;API_KEY&quot;); 方法初始化推送服务.
                - 10 如果你在发布APP的时候采用了混淆，那么记得请在混淆文件（一般默认为Android工程下proguard-project.txt或者proguard.cfg）中添加以下说明(pushservice-VERSION.jar为集成的jar包名字，VERSION为版本名称)，防止SDK内容被二次混淆，无法收到消息。（赞一个文档确实很全面啊！）
                ```-libraryjars libs/pushservice-VERSION.jar
                -dontwarn com.baidu.**
                -keep class com.baidu.**{*; }```


                ######实际使用中的一些小问题

                &gt;Manifest提示无法找到某些Activity 以及 PushService

                这个是由于相关的类被隐藏起来了，个人脑洞大开猜测应该是用的动态生成+反射技术，借此来避免相关的代码被破解吧，所以不用理会IDE中的红字，直接&lt;del&gt;食用&lt;/del&gt;即可。


                &gt;自定义Notification外观

                这一点应该是大家基本上都会用到的，毕竟自带的实在是太丑，而且再怎么说也需要换个图标吧，那么具体上有两种方式:

                - 1 则是采用百度提供的[CustomPushNotificationBuilder](http://developer.baidu.com/wiki/index.php?title=docs/cplat/push/console#.E8.87.AA.E5.AE.9A.E4.B9.89.E6.A0.B7.E5.BC.8F)直接像我们调用NotificationBuilder类似的指定我们需要的布局。

                //	第二个参数就是为你目前设置的自定义Builder设置一个ID
                //	在你进行推送的时候就可以使用预定义的模板
                PushManager.setNotificationBuilder(this, 1, builder);


                - 2 二则是使用文字推送，比如推送JSON过来由我们在我们的Receiver中的onMessage方法内部进行解析与处理，调用我们的方法来实现自定义的方式。

                &gt;定义用户点击Notification的后续事件

                这一点首先我们来看看百度提供的推送功能的介绍图片
                ![百度推送](http://bcs.duapp.com/cplat-01/push%2Fimg%2Fpush_advance.png)

                首先在通知栏样式这一块中，自定义样式就是填上上面你所指定的Builder的ID。

                后续行为这块则是大多数情况下都需要进行自定义指定的，这点百度的[文档](http://developer.baidu.com/wiki/index.php?title=docs/cplat/push/console#.E8.87.AA.E5.AE.9A.E4.B9.89.E6.89.93.E5.BC.80.E8.A1.8C.E4.B8.BA)也有较详细的说明。

                值得注意是多数情况下你需要在你想打开的某些Activity的标签内添加属性

                android:exported=&quot;true&quot;

                脑洞大开：这是因为用户的手机内部肯定不止你自己的应用，也会有很多别家的App程序，那么首先他们也是会用到百度云作为推送机制的，比如某些时候你打开你的App后，什么大众点评之类的也会收到了推送，这就是因为你在打开你的App之后，会相应地启动一个远程的Service独立于你的App之外运行，而这应该就是百度在后台维护的一个Service，并且它也让你在Manifest中注册了较多的系统事件Receiver来最大可能的保证Service能够在被杀掉后重新启动。。。
                好像扯远了，这个参数就是为了能让百度的Service能够跨应用打开你所指定的Activity。

                &gt;推送一般的消息

                这个功能由于我自己也没有具体的使用经验，但是我个人感觉应该是比较常用的，比如最简单的我们把相关的数据采用JSON格式进行推送（当然，百度推送的高级功能里面也支持我们自己添加相应的键值对数据）

                &gt;推送百度的富媒体消息

                这个首先我们要在Manifest中注册相关的几个Activity，就可以实现富媒体消息的推送了，大概原理猜测就是采用类似webview的方式，将推送过来的html解析，或者是百度直接生成了一个供webview访问的页面，并用activity嵌套webview的方式实现了该效果。

                百度的推送差不多个人的实践就到这里了，说实话相关的文档确实是很全面的，全面到我感觉写这辩笔记我只是在做一些复制粘贴，最后再次对百度推送文档的书写者赞一个吧！


            </column>
            <column name="html">&lt;blockquote&gt;
                &lt;p&gt;关于推送的学习-百度云推送&lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;p&gt;由于之前的相关SDK一直采用百度的，虽然感觉百度的经常被大家诟病，但是&lt;a href=&quot;http://push.baidu.com/doc/android/api&quot;&gt;相关的文档&lt;/a&gt;应该是算相当完善与贴近我这种新手的，下面就说一下对百度云推送的使用小经验~&lt;/p&gt;

                &lt;h6 id=&quot;&quot;&gt;要使用百度云推送，首先要进行下面几个步骤:&lt;/h6&gt;

                &lt;ul&gt;
                &lt;li&gt;1 &lt;del&gt;注册成为百度开发者.&lt;/li&gt;
                &lt;li&gt;2 前往网站下载相关的&lt;a href=&quot;http://push.baidu.com/download&quot;&gt;SDK&lt;/a&gt;.&lt;/li&gt;
                &lt;li&gt;3 &lt;a href=&quot;http://push.baidu.com/console/app/list&quot;&gt;申请&lt;/a&gt;你需要的 API KEY, 并把你的项目的包名添加进去.&lt;/li&gt;
                &lt;li&gt;4 将SDK中的jar, so文件引入项目中的正确位置.&lt;/li&gt;
                &lt;li&gt;5 在Manifest.xml中申请推送所需要的权限.&lt;/li&gt;
                &lt;li&gt;6 同样在Manifest.xml中注册相关的推送服务的百度Service, 百度的Receiver,富文本读取用的Activity(可选).&lt;/li&gt;
                &lt;li&gt;7 如果你实现了自己的Appilcation, 那么你可以将你的Application继承自FrontiaApplication,或者是在onCreate()方法中调用&lt;code&gt;FrontiaApplication.initFrontia(Context context)&lt;/code&gt; 如果没有则你需要在指定Application标签的name属性为&lt;code&gt;&quot;com.baidu.frontia.FrontiaApplication&quot;.&lt;/code&gt;&lt;/li&gt;
                &lt;li&gt;8 实现自己的处理推送的Receiver并继承FrontiaPushMessageReceiver, 并实现其中的相应接口函数.&lt;/li&gt;
                &lt;li&gt;9 利用PushManager.startWork(getApplicationContext(),
                PushConstants.LOGIN&lt;em&gt;TYPE&lt;/em&gt;API&lt;em&gt;KEY,
                &quot;API&lt;/em&gt;KEY&quot;); 方法初始化推送服务.&lt;/li&gt;
                &lt;li&gt;10 如果你在发布APP的时候采用了混淆，那么记得请在混淆文件（一般默认为Android工程下proguard-project.txt或者proguard.cfg）中添加以下说明(pushservice-VERSION.jar为集成的jar包名字，VERSION为版本名称)，防止SDK内容被二次混淆，无法收到消息。（赞一个文档确实很全面啊！）
                &lt;code&gt;-libraryjars libs/pushservice-VERSION.jar
                -dontwarn com.baidu.**
                -keep class com.baidu.**{*; }&lt;/code&gt;&lt;/li&gt;
                &lt;/ul&gt;

                &lt;h6 id=&quot;&quot;&gt;实际使用中的一些小问题&lt;/h6&gt;

                &lt;blockquote&gt;
                &lt;p&gt;Manifest提示无法找到某些Activity 以及 PushService &lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;p&gt;这个是由于相关的类被隐藏起来了，个人脑洞大开猜测应该是用的动态生成+反射技术，借此来避免相关的代码被破解吧，所以不用理会IDE中的红字，直接&lt;del&gt;食用&lt;/del&gt;即可。&lt;/p&gt;

                &lt;blockquote&gt;
                &lt;p&gt;自定义Notification外观&lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;p&gt;这一点应该是大家基本上都会用到的，毕竟自带的实在是太丑，而且再怎么说也需要换个图标吧，那么具体上有两种方式:&lt;/p&gt;

                &lt;ul&gt;
                &lt;li&gt;&lt;p&gt;1 则是采用百度提供的&lt;a href=&quot;http://developer.baidu.com/wiki/index.php?title=docs/cplat/push/console#.E8.87.AA.E5.AE.9A.E4.B9.89.E6.A0.B7.E5.BC.8F&quot;&gt;CustomPushNotificationBuilder&lt;/a&gt;直接像我们调用NotificationBuilder类似的指定我们需要的布局。&lt;/p&gt;

                &lt;pre&gt;&lt;code&gt;//    第二个参数就是为你目前设置的自定义Builder设置一个ID
                //    在你进行推送的时候就可以使用预定义的模板
                PushManager.setNotificationBuilder(this, 1, builder);
                &lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
                &lt;li&gt;&lt;p&gt;2 二则是使用文字推送，比如推送JSON过来由我们在我们的Receiver中的onMessage方法内部进行解析与处理，调用我们的方法来实现自定义的方式。&lt;/p&gt;&lt;/li&gt;
                &lt;/ul&gt;

                &lt;blockquote&gt;
                &lt;p&gt;定义用户点击Notification的后续事件&lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;p&gt;这一点首先我们来看看百度提供的推送功能的介绍图片
                &lt;img src=&quot;http://bcs.duapp.com/cplat-01/push%2Fimg%2Fpush_advance.png&quot; alt=&quot;百度推送&quot; /&gt;&lt;/p&gt;

                &lt;p&gt;首先在通知栏样式这一块中，自定义样式就是填上上面你所指定的Builder的ID。&lt;/p&gt;

                &lt;p&gt;后续行为这块则是大多数情况下都需要进行自定义指定的，这点百度的&lt;a href=&quot;http://developer.baidu.com/wiki/index.php?title=docs/cplat/push/console#.E8.87.AA.E5.AE.9A.E4.B9.89.E6.89.93.E5.BC.80.E8.A1.8C.E4.B8.BA&quot;&gt;文档&lt;/a&gt;也有较详细的说明。&lt;/p&gt;

                &lt;p&gt;值得注意是多数情况下你需要在你想打开的某些Activity的标签内添加属性&lt;/p&gt;

                &lt;pre&gt;&lt;code&gt;    android:exported=&quot;true&quot;
                &lt;/code&gt;&lt;/pre&gt;

                &lt;p&gt;脑洞大开：这是因为用户的手机内部肯定不止你自己的应用，也会有很多别家的App程序，那么首先他们也是会用到百度云作为推送机制的，比如某些时候你打开你的App后，什么大众点评之类的也会收到了推送，这就是因为你在打开你的App之后，会相应地启动一个远程的Service独立于你的App之外运行，而这应该就是百度在后台维护的一个Service，并且它也让你在Manifest中注册了较多的系统事件Receiver来最大可能的保证Service能够在被杀掉后重新启动。。。
                好像扯远了，这个参数就是为了能让百度的Service能够跨应用打开你所指定的Activity。&lt;/p&gt;

                &lt;blockquote&gt;
                &lt;p&gt;推送一般的消息&lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;p&gt;这个功能由于我自己也没有具体的使用经验，但是我个人感觉应该是比较常用的，比如最简单的我们把相关的数据采用JSON格式进行推送（当然，百度推送的高级功能里面也支持我们自己添加相应的键值对数据）&lt;/p&gt;

                &lt;blockquote&gt;
                &lt;p&gt;推送百度的富媒体消息&lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;p&gt;这个首先我们要在Manifest中注册相关的几个Activity，就可以实现富媒体消息的推送了，大概原理猜测就是采用类似webview的方式，将推送过来的html解析，或者是百度直接生成了一个供webview访问的页面，并用activity嵌套webview的方式实现了该效果。&lt;/p&gt;

                &lt;p&gt;百度的推送差不多个人的实践就到这里了，说实话相关的文档确实是很全面的，全面到我感觉写这辩笔记我只是在做一些复制粘贴，最后再次对百度推送文档的书写者赞一个吧！&lt;/p&gt;</column>
            <column name="image">NULL</column>
            <column name="featured">0</column>
            <column name="page">0</column>
            <column name="status">published</column>
            <column name="language">en_US</column>
            <column name="meta_title">NULL</column>
            <column name="meta_description">NULL</column>
            <column name="author_id">1</column>
            <column name="created_at">2015-03-26 08:26:02</column>
            <column name="created_by">1</column>
            <column name="updated_at">2015-04-02 11:40:49</column>
            <column name="updated_by">1</column>
            <column name="published_at">2015-03-31 10:44:17</column>
            <column name="published_by">1</column>
        </table>
        <table name="posts">
            <column name="id">17</column>
            <column name="uuid">4690c80b-3faf-4fb2-b922-d9313c7c8926</column>
            <column name="title">Android 推送分享等功能基于SDK的开发学习（二）</column>
            <column name="slug">android-tui-song-fen-xiang-gong-neng-ji-yu-sdkde-kai-fa-xue-xi-er</column>
            <column name="markdown">######这次主要还是自己加深一下对分享功能的研究吧，毕竟这个功能对于商业型项目或者推广自己的个人项目感觉还是相当实用的^_^

                &gt;简单介绍一下分享功能的一些花边

                首先我们知道，在Manifest中对Activity的Intent-Filter进行一些修改，可以让你的Activity可以在某种条件下(_Category_)，支持系统的某种行为(_Action_)，某种数据的打开(_Data_)，当你在操作手机的时候，满足了以上你在Intent-filter中指定的所有条件后，你的这个Activity便能够出现在可以处理当前情况的候选列表中。

                以上的这种情况称为隐式的Intent，与我们最常用的指定了某个具体Class不同的另一种情况，在这种情况下，系统会发出一个请求“哎！同志们听好了，我现在需要一个Default小组的人，能把View这个事办好，对了，你还必须是专门处理magnet情况的专家，听明白没？不符合条件的别瞎来凑热闹!”这个时候所有满足你指定条件的对象便都出现在了候选列表中，这就是一种隐式的intent。

                比如下面这个Activity
                ```
                &lt;intent-filter&gt;
                &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt;
                &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;
                &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&gt;
                &lt;data android:scheme=&quot;magnet&quot; /&gt;
                &lt;/intent-filter&gt;
                ```

                - 1 首先他指定行为类型必须为VIEW，相关的ACTION请参照[胡言乱语的博客](http://www.cnblogs.com/Android_2011/archive/2011/06/12/2078643.html)。
                - 2 其次他指定了两种类型，且必须都满足才可以。
                - 3 最后他指定了数据类型是magnet开头的。

                那么当你在浏览器内打开一个magnet开头的链接的时候就会符合触发这个条件啦，也是&lt;del&gt;神器115网盘用的一种很方便的下载手段&lt;/del&gt;。

                如果希望对隐式Intent有一个更全面的了解，参见[哈希Map的博客](http://blog.csdn.net/h3c4lenovo/article/details/7722259)，博主也是很生动的介绍了相关的知识点。

                同样的，对于Service我们也可以采用隐式intent来实现跨应用的启动~

                &gt;如何调用分享接口？

                既然已经了解到隐式intent为何物，那么自然可以很轻松的使用分享功能！

                - 1 首先创建一个Intent对象share，并指定为Intent.ACTION_SEND。
                - 2 已分享图片为例，将文件采用Uri.fromFile(File)方法转为Uri传入参数中，如
                ```
                share.putExtra(Intent.EXTRA_STREAM, Uri.fromFile(file));
                ```
                - 3 设置类型为&quot;iamge/*&quot;。
                ```
                share.setType(&quot;image/*&quot;);
                ```
                - 4 直接startActivity 或者采用 Intent.createChooser(intent, title) 来指定你在分享的时候弹出框上面的文字。

                这样，一个简单的分享操作就算完毕了~

                &gt;如何让你的程序能够接收到别人的分享操作

                相信这一点大家都能很快的实现了，也就是在你指定的Activity内指定相应的Action，Category，Data。

                至于如何处理数据，这一点跟我们平时使用Intent传递数据是一样的，我们只需要通过getIntent()方法获取传输的intent对象，即可从中取出相应的内容，数据，进行进一步的操作。

                &gt;进阶:如何用shareSDK实现授权，第三方认证

                待续~

            </column>
            <column name="html">&lt;h6 id=&quot;_&quot;&gt;这次主要还是自己加深一下对分享功能的研究吧，毕竟这个功能对于商业型项目或者推广自己的个人项目感觉还是相当实用的^_^&lt;/h6&gt;

                &lt;blockquote&gt;
                &lt;p&gt;简单介绍一下分享功能的一些花边&lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;p&gt;首先我们知道，在Manifest中对Activity的Intent-Filter进行一些修改，可以让你的Activity可以在某种条件下(&lt;em&gt;Category&lt;/em&gt;)，支持系统的某种行为(&lt;em&gt;Action&lt;/em&gt;)，某种数据的打开(&lt;em&gt;Data&lt;/em&gt;)，当你在操作手机的时候，满足了以上你在Intent-filter中指定的所有条件后，你的这个Activity便能够出现在可以处理当前情况的候选列表中。&lt;/p&gt;

                &lt;p&gt;以上的这种情况称为隐式的Intent，与我们最常用的指定了某个具体Class不同的另一种情况，在这种情况下，系统会发出一个请求“哎！同志们听好了，我现在需要一个Default小组的人，能把View这个事办好，对了，你还必须是专门处理magnet情况的专家，听明白没？不符合条件的别瞎来凑热闹!”这个时候所有满足你指定条件的对象便都出现在了候选列表中，这就是一种隐式的intent。&lt;/p&gt;

                &lt;p&gt;比如下面这个Activity&lt;/p&gt;

                &lt;pre&gt;&lt;code&gt;&amp;lt;intent-filter&amp;gt;
                &amp;lt;action android:name=&quot;android.intent.action.VIEW&quot; /&amp;gt;
                &amp;lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&amp;gt;
                &amp;lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&amp;gt;
                &amp;lt;data android:scheme=&quot;magnet&quot; /&amp;gt;
                &amp;lt;/intent-filter&amp;gt;
                &lt;/code&gt;&lt;/pre&gt;

                &lt;ul&gt;
                &lt;li&gt;1 首先他指定行为类型必须为VIEW，相关的ACTION请参照&lt;a href=&quot;http://www.cnblogs.com/Android_2011/archive/2011/06/12/2078643.html&quot;&gt;胡言乱语的博客&lt;/a&gt;。&lt;/li&gt;
                &lt;li&gt;2 其次他指定了两种类型，且必须都满足才可以。&lt;/li&gt;
                &lt;li&gt;3 最后他指定了数据类型是magnet开头的。&lt;/li&gt;
                &lt;/ul&gt;

                &lt;p&gt;那么当你在浏览器内打开一个magnet开头的链接的时候就会符合触发这个条件啦，也是&lt;del&gt;神器115网盘用的一种很方便的下载手段&lt;/del&gt;。&lt;/p&gt;

                &lt;p&gt;如果希望对隐式Intent有一个更全面的了解，参见&lt;a href=&quot;http://blog.csdn.net/h3c4lenovo/article/details/7722259&quot;&gt;哈希Map的博客&lt;/a&gt;，博主也是很生动的介绍了相关的知识点。&lt;/p&gt;

                &lt;p&gt;同样的，对于Service我们也可以采用隐式intent来实现跨应用的启动~&lt;/p&gt;

                &lt;blockquote&gt;
                &lt;p&gt;如何调用分享接口？&lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;p&gt;既然已经了解到隐式intent为何物，那么自然可以很轻松的使用分享功能！&lt;/p&gt;

                &lt;ul&gt;
                &lt;li&gt;1 首先创建一个Intent对象share，并指定为Intent.ACTION_SEND。&lt;/li&gt;
                &lt;li&gt;2 已分享图片为例，将文件采用Uri.fromFile(File)方法转为Uri传入参数中，如&lt;/li&gt;
                &lt;/ul&gt;

                &lt;pre&gt;&lt;code&gt;share.putExtra(Intent.EXTRA_STREAM, Uri.fromFile(file));
                &lt;/code&gt;&lt;/pre&gt;

                &lt;ul&gt;
                &lt;li&gt;3 设置类型为&quot;iamge/*&quot;。&lt;/li&gt;
                &lt;/ul&gt;

                &lt;pre&gt;&lt;code&gt;share.setType(&quot;image/*&quot;);
                &lt;/code&gt;&lt;/pre&gt;

                &lt;ul&gt;
                &lt;li&gt;4 直接startActivity 或者采用 Intent.createChooser(intent, title) 来指定你在分享的时候弹出框上面的文字。&lt;/li&gt;
                &lt;/ul&gt;

                &lt;p&gt;这样，一个简单的分享操作就算完毕了~&lt;/p&gt;

                &lt;blockquote&gt;
                &lt;p&gt;如何让你的程序能够接收到别人的分享操作&lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;p&gt;相信这一点大家都能很快的实现了，也就是在你指定的Activity内指定相应的Action，Category，Data。&lt;/p&gt;

                &lt;p&gt;至于如何处理数据，这一点跟我们平时使用Intent传递数据是一样的，我们只需要通过getIntent()方法获取传输的intent对象，即可从中取出相应的内容，数据，进行进一步的操作。&lt;/p&gt;

                &lt;blockquote&gt;
                &lt;p&gt;进阶:如何用shareSDK实现授权，第三方认证&lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;p&gt;待续~&lt;/p&gt;</column>
            <column name="image">NULL</column>
            <column name="featured">0</column>
            <column name="page">0</column>
            <column name="status">published</column>
            <column name="language">en_US</column>
            <column name="meta_title">NULL</column>
            <column name="meta_description">NULL</column>
            <column name="author_id">1</column>
            <column name="created_at">2015-04-02 09:27:52</column>
            <column name="created_by">1</column>
            <column name="updated_at">2015-04-02 11:41:01</column>
            <column name="updated_by">1</column>
            <column name="published_at">2015-04-02 10:20:58</column>
            <column name="published_by">1</column>
        </table>
        <table name="posts">
            <column name="id">18</column>
            <column name="uuid">ca2801e3-6588-4c91-a4a0-050f1a4c0b78</column>
            <column name="title">Android 推送分享等功能基于SDK的开发学习（三）第三方登陆的实现</column>
            <column name="slug">android-tui-song-fen-xiang-gong-neng-ji-yu-sdkde-kai-fa-xue-xi-san-di-san-fang-deng-lu-de-shi-xian</column>
            <column name="markdown"></column>
            <column name="html"></column>
            <column name="image">NULL</column>
            <column name="featured">0</column>
            <column name="page">0</column>
            <column name="status">draft</column>
            <column name="language">en_US</column>
            <column name="meta_title">NULL</column>
            <column name="meta_description">NULL</column>
            <column name="author_id">1</column>
            <column name="created_at">2015-04-02 11:29:48</column>
            <column name="created_by">1</column>
            <column name="updated_at">2015-04-02 11:40:37</column>
            <column name="updated_by">1</column>
            <column name="published_at">NULL</column>
            <column name="published_by">NULL</column>
        </table>
        <table name="posts">
            <column name="id">19</column>
            <column name="uuid">b306bb8d-2c07-41c1-ad98-7d918ff9efbc</column>
            <column name="title">Python 学习笔记 1</column>
            <column name="slug">python-xue-xi-bi-ji-1</column>
            <column name="markdown">```
                #!/usr/bin/python
                #coding=utf-8
                import HTMLParser
                import urlparse
                import urllib
                import urllib2
                import cookielib
                import string
                import re
                import time

                def download(id):
                # print
                print id
                # 用到的URL地址 普通地址与登陆地址
                hosturl = 'http://cas.sias.edu.cn/portal'
                posturl = 'http://cas.sias.edu.cn/portal/xlogin'

                # 首先先模拟打开网站 获取cookie# 用到的URL地址 普通地址与登陆地址
                cj = cookielib.LWPCookieJar()
                cookie_support = urllib2.HTTPCookieProcessor(cj)
                opener = urllib2.build_opener(cookie_support, urllib2.HTTPHandler)
                urllib2.install_opener(opener)
                h = urllib2.urlopen(hosturl)

                # 封装数据头 与 表单数据
                headers = {'User-Agent' : 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:14.0) Gecko/20100101 Firefox/14.0.1','Referer' : 'http://cas.sias.edu.cn/portal'}
                postData = {'eid':id, 'pw':'123456', 'submit':'登陆'}
                postData = urllib.urlencode(postData)

                # 发起访问请求
                request = urllib2.Request(posturl, postData, headers)
                response = urllib2.urlopen(request)
                text = response.read()

                # 根据返回的信息提取出动态生成的主页信息
                pattern = &quot;&lt;a class=\&quot;toolMenuLink \&quot; href=\&quot;(.+?)\&quot; title=\&quot;个人资料工具\&quot;&gt;&quot;
                linkPattern = re.compile(pattern)
                if len(linkPattern.findall(text)) &gt; 0:
                infoUrl = linkPattern.findall(text)[0]
                else:
                print &quot;Wrong Password&quot;
                return

                # 根据页面URL访问并提取 用户名 以及 用户资料页面的地址
                response = urllib2.urlopen(infoUrl)
                text = response.read()
                pattern = &quot;src=\&quot;(.+?)\&quot;&gt;&quot;
                linkPattern = re.compile(pattern)
                infoUrl = linkPattern.findall(text)
                mainUrl = infoUrl[-1]

                # 访问用户资料页面 并提取 拼接 用户头像的URL
                response = urllib2.urlopen(mainUrl)
                text = response.read()
                pattern = &quot;&lt;span id=\&quot;profileHeadingName\&quot;&gt;(.+?)&lt;/span&gt;&quot;
                linkPattern = re.compile(pattern)
                username = linkPattern.findall(text)[0].split(' ')[-1].decode('utf8')

                # 找出用户头像的URL后缀
                pattern = &quot;&lt;img src=\&quot;(.+?)\&quot;&quot;
                linkPattern = re.compile(pattern)
                imageUrl = mainUrl.split('?')[0] + '/' + linkPattern.findall(text)[0]
                imageUrl = imageUrl.replace('&amp;amp;', '&amp;')
                print imageUrl

                # 下载用户头像 并保存文件
                f = open(id+'_'+username+'.png', 'wb')
                try:
                response = urllib2.urlopen(imageUrl)
                f.write(response.read())
                print 'Done'
                except:
                print 'Error'
                finally:
                f.close()

                # 循环运行  拓展 多线程循环运行
                id = '2011'
                for i in range(1811338, 1811999):
                download(id+str(i).zfill(7))
                ```</column>
            <column name="html">&lt;pre&gt;&lt;code&gt;#!/usr/bin/python
                #coding=utf-8
                import HTMLParser
                import urlparse
                import urllib
                import urllib2
                import cookielib
                import string
                import re
                import time

                def download(id):
                # print
                print id
                # 用到的URL地址 普通地址与登陆地址
                hosturl = 'http://cas.sias.edu.cn/portal'
                posturl = 'http://cas.sias.edu.cn/portal/xlogin'

                # 首先先模拟打开网站 获取cookie# 用到的URL地址 普通地址与登陆地址
                cj = cookielib.LWPCookieJar()
                cookie_support = urllib2.HTTPCookieProcessor(cj)
                opener = urllib2.build_opener(cookie_support, urllib2.HTTPHandler)
                urllib2.install_opener(opener)
                h = urllib2.urlopen(hosturl)

                # 封装数据头 与 表单数据
                headers = {'User-Agent' : 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:14.0) Gecko/20100101 Firefox/14.0.1','Referer' : 'http://cas.sias.edu.cn/portal'}
                postData = {'eid':id, 'pw':'123456', 'submit':'登陆'}
                postData = urllib.urlencode(postData)

                # 发起访问请求
                request = urllib2.Request(posturl, postData, headers)
                response = urllib2.urlopen(request)
                text = response.read()

                # 根据返回的信息提取出动态生成的主页信息
                pattern = &quot;&amp;lt;a class=\&quot;toolMenuLink \&quot; href=\&quot;(.+?)\&quot; title=\&quot;个人资料工具\&quot;&amp;gt;&quot;
                linkPattern = re.compile(pattern)
                if len(linkPattern.findall(text)) &amp;gt; 0:
                infoUrl = linkPattern.findall(text)[0]
                else:
                print &quot;Wrong Password&quot;
                return

                # 根据页面URL访问并提取 用户名 以及 用户资料页面的地址
                response = urllib2.urlopen(infoUrl)
                text = response.read()
                pattern = &quot;src=\&quot;(.+?)\&quot;&amp;gt;&quot;
                linkPattern = re.compile(pattern)
                infoUrl = linkPattern.findall(text)
                mainUrl = infoUrl[-1]

                # 访问用户资料页面 并提取 拼接 用户头像的URL
                response = urllib2.urlopen(mainUrl)
                text = response.read()
                pattern = &quot;&amp;lt;span id=\&quot;profileHeadingName\&quot;&amp;gt;(.+?)&amp;lt;/span&amp;gt;&quot;
                linkPattern = re.compile(pattern)
                username = linkPattern.findall(text)[0].split(' ')[-1].decode('utf8')

                # 找出用户头像的URL后缀
                pattern = &quot;&amp;lt;img src=\&quot;(.+?)\&quot;&quot;
                linkPattern = re.compile(pattern)
                imageUrl = mainUrl.split('?')[0] + '/' + linkPattern.findall(text)[0]
                imageUrl = imageUrl.replace('&amp;amp;amp;', '&amp;amp;')
                print imageUrl

                # 下载用户头像 并保存文件
                f = open(id+'_'+username+'.png', 'wb')
                try:
                response = urllib2.urlopen(imageUrl)
                f.write(response.read())
                print 'Done'
                except:
                print 'Error'
                finally:
                f.close()

                # 循环运行  拓展 多线程循环运行
                id = '2011'
                for i in range(1811338, 1811999):
                download(id+str(i).zfill(7))
                &lt;/code&gt;&lt;/pre&gt;</column>
            <column name="image">NULL</column>
            <column name="featured">0</column>
            <column name="page">0</column>
            <column name="status">published</column>
            <column name="language">en_US</column>
            <column name="meta_title">NULL</column>
            <column name="meta_description">NULL</column>
            <column name="author_id">1</column>
            <column name="created_at">2015-04-07 15:53:09</column>
            <column name="created_by">1</column>
            <column name="updated_at">2015-04-08 15:39:02</column>
            <column name="updated_by">1</column>
            <column name="published_at">2015-04-08 15:39:02</column>
            <column name="published_by">1</column>
        </table>
        <table name="posts">
            <column name="id">20</column>
            <column name="uuid">6e99f919-3128-4a2b-8b3e-7fe0fd190cd1</column>
            <column name="title">Android 环形转动菜单学习笔记 2</column>
            <column name="slug">android-huan-xing-zhuan-dong-cai-dan-xue-xi-bi-ji-2</column>
            <column name="markdown">######接着[上文](http://blazers.duapp.com/android-huan-xing-zhuan-dong-cai-dan-de-shi-xian/)继续拓展学习
                &lt;br/&gt;
                之前在学习环形菜单的项目中，遇到了一个问题：当我在构造函数中为ViewGroup添加item的时候，如果在此时没有调用item.setClickable(true)，那么我在ViewGroup中的dispatchTouchEvent()方法中就只能捕捉**TOUCH\_DOWN**事件，而无法捕捉到**TOUCH\_MOVE**与**TOUCH\_UP**事件，因为此时我的dispatchTouchEvent()方法是调用的父类的方法进行返回值的处理，所以我们就来看看父类ViewGroup的相关方法究竟做了什么把。

                &gt;看之前需要有一个大致印象的知识点：事件传递

                ![](http://i1.tietuku.com/ac21182be65faafe.png)

                - 1 图中有五个控件，分别为：
                - 0 最外层的LinearLayout Root
                - 1 &lt;b style=&quot;color:#330099&quot;&gt;左侧紫色自定义ViewGroup **Left Frame**&lt;/b&gt;
                - 2 &lt;b style=&quot;color:#991834&quot;&gt;右侧红色自定义ViewGroup **Right Frame**&lt;/b&gt;
                - 3 左侧包含的TextView
                - 4 右侧包含的Button

                &lt;br&gt;
                - 2 首先我们触摸并滑动左侧的TextView区域，看一看Log输出(关于方法的复写暂时不表)

                ACTION_DOWN = 0;
                ACTION_UP = 1;
                ACTION_MOVE = 2;

                ![](http://i2.tietuku.com/2c2809910cca95bf.png)

                如图，根据Log输出我们看一看事件传递的顺序

                首先Activity的 Dispatch 接收到 DOWN 事件 然后调用父类的该方法进行处理 这个是一般情况下事件的入口。

                随后在Activity 将事件送入 Root的 Dispatch 方法， Root层接收到后将事件送到同一层的 Intercept 中进行处理，注意此时前面两个 Dispatch 方法并未执行结束，他需要等待 Intercept 执行的结果，我们通过查看ViewGroup中 intercept 方法的源码，发现他只有一行代码 'return false', 也就是默认情况下都是不去拦截事件的，除非开发者复写后进行一些修改。

                随后 Intercept 方法彻底执行完毕，并返回了false，随后在 Dispatch 方法中间的某一步捕捉到该返回结果后，把事件向下传递给 Left Frame。

                同样Left Frame的 Dispatch 接收到DOWN事件，如同Root层的处理流程，又继续将事件下发到下面的 TextView , 注意此时 Root的 Dispatch 方法 与 Left Frame 的 Dispatch 方法均未执行完毕， 想象一下递归的感觉~

                紧接着 TextView 的 Dispatch 方法接收到上级的时间后， 由于TextView并非继承自ViewGroup故不能包含子View，也就没有对子对象所谓的“拦截”需求，我们在View与ViewGroup的源码中可以看到View的dispach方法并未调用intercept（因为该方法是ViewGroup独有的...），通过简单的分析源码&lt;del&gt;复杂的我也看不懂啊...&lt;/del&gt;，我们看到在View的 dispatch 方法中，调用了 onTouchEvent() 方法，所以我们就能在Log中看到。

                随后我们观察 TextView 中 的onTouchEvent() 方法，可见TextView对View中的onTouchEvent()进行了复写：主要是为了针对同样继承自TextView的EditText实现的相关输入法弹出，长按选中文字的一些特殊需求。

                总之，如果事件没有被处理，onTouchEvent()方法就会返回false，随后 dispatch 方法在得知结果之后，也终于一个一个开始结束掉漫长的等待，至此一个DOWN类型的事件处理完毕。

                但DOWN类型事件也仅仅是触摸事件的开始。

                随后开始触发滑动事件，也即是MOVE的开始，按理说应该跟上面一样，在处理上这应该是毅种循环吧。

                &lt;del&gt;我本以为我会暴富，但是我没有&lt;/del&gt;

                但是！通过查看Log，当滑动的时候并没有按照我们预想的路线继续传递一遍！

                为何？

                为了寻求真想，我决定到Activity中的Dispatch方法中寻求一下~

                &gt;Activity中dispatch的处理

                首先我们来看看Activity中dispatchTouchEvent()方法的源代码
                ```
                public boolean dispatchTouchEvent(MotionEvent ev) {
                if (ev.getAction() == MotionEvent.ACTION_DOWN) {
                onUserInteraction();
                }
                if (getWindow().superDispatchTouchEvent(ev)) {
                return true;
                }
                return onTouchEvent(ev);
                }
                ```
                我们看到了，当事件类型为DOWN的时候，会调用onUserInteraction()方法。
                而所谓的onUserInteraction()方法，其实就是谷歌为开发者留的一个接口，用于开发着第一时间捕捉到触摸事件的开始事件(DOWN)，开发者通过在Activity中复写该方法进行一些额外的处理。

                随后我们在看下面的 getWindow().superDispatchTouchEvent(ev)，不过我们知道Log中并未返回true，所以该方法肯定也返回了false，但我们看了看getWindow()方法就应该知道其实就是把时间送到DecorView中进行处理，至于其中进行了什么，我们日后在探究。

                所以我们还是看调用的onTouchEvent()，毕竟这才是返回false的直接原因。

                ```
                public boolean onTouchEvent(MotionEvent event) {
                if (mWindow.shouldCloseOnTouch(this, event)) {
                finish();
                return true;
                }
                return false;
                }
                ```

                很简单的几行代码，首先我们看一看谷歌的官方注释：
                Called when a touch screen event was not handled by any of the views under it.
                啥意思呢？也就是我们刚才看的那一段，由于getWindow().superDispatchTouchEvent(ev)方法中发现没人去处理这个东西，所以才能运行到这一块。

                虽然看不太懂这块究竟是什么，但我们看到finish()方法，以及其他的返回结果就知道其实事情的关键还不在这边。

                依然在getWindow().superDispatchTouchEvent(ev)，这个方法中，为何DOWN的时候，该方法还会把时间向下传递，而到了MOVE的时候该方法就不再向下传递方法了呢？

                &gt;superDispatchTouchEvent()源码查看

                ```
                @Override
                public boolean superDispatchTouchEvent(MotionEvent event) {
                return mDecor.superDispatchTouchEvent(event);
                }
                ```

                可见依然是我们所说的DecotView中的方法，至于DecorView在先前的博文中也提到过，是整个窗口的最Root的View，继承自FrameLayout，我们来看看它的相关方法。

                ```
                public boolean superDispatchTouchEvent(MotionEvent event) {
                return super.dispatchTouchEvent(event);
                }
                ```

                哈哈，也就是他调用的还是FrameLayout中的dispatchTouchEvent()，最后绕了一圈还是绕回来了，那么我们就仔细分析一下ViewGroup或FrameLayout中 dispatchTouchEvent()方法究竟干了什么。

                &gt;dispatchTouchEvent（）的源头

                这块代码很长很长，我们就一点一点来分析。

                - 1 ```
                if (mInputEventConsistencyVerifier != null) {
                mInputEventConsistencyVerifier.onTouchEvent(ev, 1);
                }
                ```
                //	不太清楚，但应该挺重要，我们稍后来看

                - 2 第二段是最长的一段同样也是最重要的一段 ```
                if (onFilterTouchEventForSecurity(ev))
                //  首先检测这个时间是否合法 不合法则直接丢弃
                ...
                // handle an initial down
                if (actionMasked == MotionEvent.ACTION_DOWN) {
                // Throw away all previous state when starting a new touch gesture.
                // The framework may have dropped the up or cancel event for the previous gesture
                // due to an app switch, ANR, or some other state change.
                cancelAndClearTouchTargets(ev);
                resetTouchState();
                }
                //	大致意思是接收到DOWN类型的事件后，将所有状态重置一边，做一次全新的处理
                ...
                // Check for interception.
                final boolean intercepted;
                if (actionMasked == MotionEvent.ACTION_DOWN
                || mFirstTouchTarget != null) {
                final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;
                if (!disallowIntercept) {
                intercepted = onInterceptTouchEvent(ev);
                ev.setAction(action); // restore action in case it was changed
                } else {
                intercepted = false;
                }
                } else {
                // There are no touch targets and this action is not an initial down
                // so this view group continues to intercept touches.
                intercepted = true;
                }

                //	判断这个事件该不该被拦截 在这里我们要注意一下 mFirstTouchTarget 这个变量 **①**
                ...
                //	接着我们往下看
                if (!canceled &amp;&amp; !intercepted) {
                //	注意这个if语句里面的内容，这个语句执行的条件及  calceled与intercepted均为false
                ...
                //	我们略去中间的一部分，但我们可以看出来他在遍历这个ViewGroup中的子View，并且执行了一个 dispatchTransformedTouchEvent（）的方法
                //	我们通过查看该方法发现在此处调用了子child的dispatchTouchEvent()方法
                //	也就是说如果函数执行到这一段是肯定会输出子child的相关结果
                //	所以我们可以得出当一次DOWN事件后我们如果没有处理继续滑动，则函数不会执行到此处
                //	那我们就从各个的if语句的条件开始再次分析
                ...
                }

                ```
                &gt;if条件的分析

                - 1 第一个if:     **if (actionMasked == MotionEvent.ACTION_DOWN
                || mFirstTouchTarget != null)**

                我们在看源码的时候注意到，在dispatchTouchEvent()方法中唯一一次调用onInterceptTouchEvent()方法就是在这个if条件的包含范围内。

                //	暂时挂起 有些内容确实目前尚不清楚 慢慢研究~

            </column>
            <column name="html">&lt;h6 id=&quot;httpblazersduappcomandroidhuanxingzhuandongcaidandeshixian&quot;&gt;接着&lt;a href=&quot;http://blazers.duapp.com/android-huan-xing-zhuan-dong-cai-dan-de-shi-xian/&quot;&gt;上文&lt;/a&gt;继续拓展学习&lt;/h6&gt;

                &lt;p&gt;&lt;br/&gt; &lt;br /&gt;
                之前在学习环形菜单的项目中，遇到了一个问题：当我在构造函数中为ViewGroup添加item的时候，如果在此时没有调用item.setClickable(true)，那么我在ViewGroup中的dispatchTouchEvent()方法中就只能捕捉&lt;strong&gt;TOUCH_DOWN&lt;/strong&gt;事件，而无法捕捉到&lt;strong&gt;TOUCH_MOVE&lt;/strong&gt;与&lt;strong&gt;TOUCH_UP&lt;/strong&gt;事件，因为此时我的dispatchTouchEvent()方法是调用的父类的方法进行返回值的处理，所以我们就来看看父类ViewGroup的相关方法究竟做了什么把。&lt;/p&gt;

                &lt;blockquote&gt;
                &lt;p&gt;看之前需要有一个大致印象的知识点：事件传递&lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;p&gt;&lt;img src=&quot;http://i1.tietuku.com/ac21182be65faafe.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

                &lt;ul&gt;
                &lt;li&gt;&lt;p&gt;1 图中有五个控件，分别为：&lt;/p&gt;

                &lt;ul&gt;&lt;li&gt;0 最外层的LinearLayout Root&lt;/li&gt;
                &lt;li&gt;1 &lt;b style=&quot;color:#330099&quot;&gt;左侧紫色自定义ViewGroup &lt;strong&gt;Left Frame&lt;/strong&gt;&lt;/b&gt;&lt;/li&gt;
                &lt;li&gt;2 &lt;b style=&quot;color:#991834&quot;&gt;右侧红色自定义ViewGroup &lt;strong&gt;Right Frame&lt;/strong&gt;&lt;/b&gt;&lt;/li&gt;
                &lt;li&gt;3 左侧包含的TextView&lt;/li&gt;
                &lt;li&gt;4 右侧包含的Button&lt;/li&gt;&lt;/ul&gt;

                &lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;/li&gt;
                &lt;li&gt;&lt;p&gt;2 首先我们触摸并滑动左侧的TextView区域，看一看Log输出(关于方法的复写暂时不表)&lt;/p&gt;

                &lt;p&gt;ACTION&lt;em&gt;DOWN = 0;
                ACTION&lt;/em&gt;UP = 1;
                ACTION_MOVE = 2;&lt;/p&gt;

                &lt;p&gt;&lt;img src=&quot;http://i2.tietuku.com/2c2809910cca95bf.png&quot; alt=&quot;&quot; title=&quot;&quot; /&gt;&lt;/p&gt;

                &lt;p&gt;如图，根据Log输出我们看一看事件传递的顺序&lt;/p&gt;

                &lt;p&gt;首先Activity的 Dispatch 接收到 DOWN 事件 然后调用父类的该方法进行处理 这个是一般情况下事件的入口。&lt;/p&gt;

                &lt;p&gt;随后在Activity 将事件送入 Root的 Dispatch 方法， Root层接收到后将事件送到同一层的 Intercept 中进行处理，注意此时前面两个 Dispatch 方法并未执行结束，他需要等待 Intercept 执行的结果，我们通过查看ViewGroup中 intercept 方法的源码，发现他只有一行代码 'return false', 也就是默认情况下都是不去拦截事件的，除非开发者复写后进行一些修改。&lt;/p&gt;

                &lt;p&gt;随后 Intercept 方法彻底执行完毕，并返回了false，随后在 Dispatch 方法中间的某一步捕捉到该返回结果后，把事件向下传递给 Left Frame。&lt;/p&gt;

                &lt;p&gt;同样Left Frame的 Dispatch 接收到DOWN事件，如同Root层的处理流程，又继续将事件下发到下面的 TextView , 注意此时 Root的 Dispatch 方法 与 Left Frame 的 Dispatch 方法均未执行完毕， 想象一下递归的感觉~&lt;/p&gt;

                &lt;p&gt;紧接着 TextView 的 Dispatch 方法接收到上级的时间后， 由于TextView并非继承自ViewGroup故不能包含子View，也就没有对子对象所谓的“拦截”需求，我们在View与ViewGroup的源码中可以看到View的dispach方法并未调用intercept（因为该方法是ViewGroup独有的...），通过简单的分析源码&lt;del&gt;复杂的我也看不懂啊...&lt;/del&gt;，我们看到在View的 dispatch 方法中，调用了 onTouchEvent() 方法，所以我们就能在Log中看到。&lt;/p&gt;

                &lt;p&gt;随后我们观察 TextView 中 的onTouchEvent() 方法，可见TextView对View中的onTouchEvent()进行了复写：主要是为了针对同样继承自TextView的EditText实现的相关输入法弹出，长按选中文字的一些特殊需求。&lt;/p&gt;

                &lt;p&gt;总之，如果事件没有被处理，onTouchEvent()方法就会返回false，随后 dispatch 方法在得知结果之后，也终于一个一个开始结束掉漫长的等待，至此一个DOWN类型的事件处理完毕。&lt;/p&gt;

                &lt;p&gt;但DOWN类型事件也仅仅是触摸事件的开始。&lt;/p&gt;

                &lt;p&gt;随后开始触发滑动事件，也即是MOVE的开始，按理说应该跟上面一样，在处理上这应该是毅种循环吧。&lt;/p&gt;

                &lt;p&gt;&lt;del&gt;我本以为我会暴富，但是我没有&lt;/del&gt;&lt;/p&gt;

                &lt;p&gt;但是！通过查看Log，当滑动的时候并没有按照我们预想的路线继续传递一遍！&lt;/p&gt;

                &lt;p&gt;为何？&lt;/p&gt;

                &lt;p&gt;为了寻求真想，我决定到Activity中的Dispatch方法中寻求一下~&lt;/p&gt;&lt;/li&gt;
                &lt;/ul&gt;

                &lt;blockquote&gt;
                &lt;p&gt;Activity中dispatch的处理&lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;p&gt;首先我们来看看Activity中dispatchTouchEvent()方法的源代码&lt;/p&gt;

                &lt;pre&gt;&lt;code&gt;public boolean dispatchTouchEvent(MotionEvent ev) {
                if (ev.getAction() == MotionEvent.ACTION_DOWN) {
                onUserInteraction();
                }
                if (getWindow().superDispatchTouchEvent(ev)) {
                return true;
                }
                return onTouchEvent(ev);
                }
                &lt;/code&gt;&lt;/pre&gt;

                &lt;p&gt;我们看到了，当事件类型为DOWN的时候，会调用onUserInteraction()方法。
                而所谓的onUserInteraction()方法，其实就是谷歌为开发者留的一个接口，用于开发着第一时间捕捉到触摸事件的开始事件(DOWN)，开发者通过在Activity中复写该方法进行一些额外的处理。&lt;/p&gt;

                &lt;p&gt;随后我们在看下面的 getWindow().superDispatchTouchEvent(ev)，不过我们知道Log中并未返回true，所以该方法肯定也返回了false，但我们看了看getWindow()方法就应该知道其实就是把时间送到DecorView中进行处理，至于其中进行了什么，我们日后在探究。&lt;/p&gt;

                &lt;p&gt;所以我们还是看调用的onTouchEvent()，毕竟这才是返回false的直接原因。&lt;/p&gt;

                &lt;pre&gt;&lt;code&gt;public boolean onTouchEvent(MotionEvent event) {
                if (mWindow.shouldCloseOnTouch(this, event)) {
                finish();
                return true;
                }
                return false;
                }
                &lt;/code&gt;&lt;/pre&gt;

                &lt;p&gt;很简单的几行代码，首先我们看一看谷歌的官方注释：
                Called when a touch screen event was not handled by any of the views under it. &lt;br /&gt;
                啥意思呢？也就是我们刚才看的那一段，由于getWindow().superDispatchTouchEvent(ev)方法中发现没人去处理这个东西，所以才能运行到这一块。&lt;/p&gt;

                &lt;p&gt;虽然看不太懂这块究竟是什么，但我们看到finish()方法，以及其他的返回结果就知道其实事情的关键还不在这边。&lt;/p&gt;

                &lt;p&gt;依然在getWindow().superDispatchTouchEvent(ev)，这个方法中，为何DOWN的时候，该方法还会把时间向下传递，而到了MOVE的时候该方法就不再向下传递方法了呢？&lt;/p&gt;

                &lt;blockquote&gt;
                &lt;p&gt;superDispatchTouchEvent()源码查看&lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;pre&gt;&lt;code&gt;@Override
                public boolean superDispatchTouchEvent(MotionEvent event) {
                return mDecor.superDispatchTouchEvent(event);
                }
                &lt;/code&gt;&lt;/pre&gt;

                &lt;p&gt;可见依然是我们所说的DecotView中的方法，至于DecorView在先前的博文中也提到过，是整个窗口的最Root的View，继承自FrameLayout，我们来看看它的相关方法。&lt;/p&gt;

                &lt;pre&gt;&lt;code&gt;public boolean superDispatchTouchEvent(MotionEvent event) {
                return super.dispatchTouchEvent(event);
                }
                &lt;/code&gt;&lt;/pre&gt;

                &lt;p&gt;哈哈，也就是他调用的还是FrameLayout中的dispatchTouchEvent()，最后绕了一圈还是绕回来了，那么我们就仔细分析一下ViewGroup或FrameLayout中 dispatchTouchEvent()方法究竟干了什么。&lt;/p&gt;

                &lt;blockquote&gt;
                &lt;p&gt;dispatchTouchEvent（）的源头&lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;p&gt;这块代码很长很长，我们就一点一点来分析。&lt;/p&gt;

                &lt;ul&gt;
                &lt;li&gt;1 ```
                if (mInputEventConsistencyVerifier != null) {
                mInputEventConsistencyVerifier.onTouchEvent(ev, 1);
                }&lt;/li&gt;
                &lt;/ul&gt;

                &lt;pre&gt;&lt;code&gt;//    不太清楚，但应该挺重要，我们稍后来看

                - 2 第二段是最长的一段同样也是最重要的一段 ```
                if (onFilterTouchEventForSecurity(ev))
                //  首先检测这个时间是否合法 不合法则直接丢弃
                ...
                // handle an initial down
                if (actionMasked == MotionEvent.ACTION_DOWN) {
                // Throw away all previous state when starting a new touch gesture.
                // The framework may have dropped the up or cancel event for the previous gesture
                // due to an app switch, ANR, or some other state change.
                cancelAndClearTouchTargets(ev);
                resetTouchState();
                }
                //    大致意思是接收到DOWN类型的事件后，将所有状态重置一边，做一次全新的处理
                ...
                // Check for interception.
                final boolean intercepted;
                if (actionMasked == MotionEvent.ACTION_DOWN
                || mFirstTouchTarget != null) {
                final boolean disallowIntercept = (mGroupFlags &amp;amp; FLAG_DISALLOW_INTERCEPT) != 0;
                if (!disallowIntercept) {
                intercepted = onInterceptTouchEvent(ev);
                ev.setAction(action); // restore action in case it was changed
                } else {
                intercepted = false;
                }
                } else {
                // There are no touch targets and this action is not an initial down
                // so this view group continues to intercept touches.
                intercepted = true;
                }

                //    判断这个事件该不该被拦截 在这里我们要注意一下 mFirstTouchTarget 这个变量 **①**
                ...
                //    接着我们往下看
                if (!canceled &amp;amp;&amp;amp; !intercepted) {
                //  注意这个if语句里面的内容，这个语句执行的条件及  calceled与intercepted均为false
                ...
                //    我们略去中间的一部分，但我们可以看出来他在遍历这个ViewGroup中的子View，并且执行了一个 dispatchTransformedTouchEvent（）的方法
                //    我们通过查看该方法发现在此处调用了子child的dispatchTouchEvent()方法
                //    也就是说如果函数执行到这一段是肯定会输出子child的相关结果
                //    所以我们可以得出当一次DOWN事件后我们如果没有处理继续滑动，则函数不会执行到此处
                //    那我们就从各个的if语句的条件开始再次分析
                ...
                }
                &lt;/code&gt;&lt;/pre&gt;

                &lt;blockquote&gt;
                &lt;p&gt;if条件的分析&lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;ul&gt;
                &lt;li&gt;1 第一个if:     &lt;strong&gt;if (actionMasked == MotionEvent.ACTION_DOWN
                || mFirstTouchTarget != null)&lt;/strong&gt;&lt;/li&gt;
                &lt;/ul&gt;

                &lt;p&gt;我们在看源码的时候注意到，在dispatchTouchEvent()方法中唯一一次调用onInterceptTouchEvent()方法就是在这个if条件的包含范围内。&lt;/p&gt;

                &lt;p&gt;//    暂时挂起 有些内容确实目前尚不清楚 慢慢研究~&lt;/p&gt;</column>
            <column name="image">NULL</column>
            <column name="featured">0</column>
            <column name="page">0</column>
            <column name="status">published</column>
            <column name="language">en_US</column>
            <column name="meta_title">NULL</column>
            <column name="meta_description">NULL</column>
            <column name="author_id">1</column>
            <column name="created_at">2015-04-08 15:39:42</column>
            <column name="created_by">1</column>
            <column name="updated_at">2015-04-13 14:21:33</column>
            <column name="updated_by">1</column>
            <column name="published_at">2015-04-08 16:05:34</column>
            <column name="published_by">1</column>
        </table>
        <table name="posts">
            <column name="id">21</column>
            <column name="uuid">c0a43f91-8d26-41aa-9e20-a87d1c1ddf5f</column>
            <column name="title">Android 豌豆荚效果以及视差滑动效果的学习</column>
            <column name="slug">android-wan-dou-jia-xiao-guo-yi-ji-shi-chai-hua-dong-xiao-guo-de-xue-xi</column>
            <column name="markdown"></column>
            <column name="html"></column>
            <column name="image">NULL</column>
            <column name="featured">0</column>
            <column name="page">0</column>
            <column name="status">draft</column>
            <column name="language">en_US</column>
            <column name="meta_title">NULL</column>
            <column name="meta_description">NULL</column>
            <column name="author_id">1</column>
            <column name="created_at">2015-04-09 09:35:39</column>
            <column name="created_by">1</column>
            <column name="updated_at">2015-04-09 09:35:39</column>
            <column name="updated_by">1</column>
            <column name="published_at">NULL</column>
            <column name="published_by">NULL</column>
        </table>
        <table name="posts">
            <column name="id">22</column>
            <column name="uuid">476194be-3a95-4ddf-84ef-a85577073bff</column>
            <column name="title">Android 视差滚动效果的ViewGroup的实现</column>
            <column name="slug">android-shi-chai-gun-dong-xiao-guo-de-viewgroupde-shi-xian</column>
            <column name="markdown">[最美应用](http://zuimeia.com/)是一款很Nice的App，会经常推荐很多不错的应用给你，在最近的更新后，应用的主页采用了视差滑动的效果，效果很不错，见下图：



                ![最美应用](http://i2.tietuku.com/a818e9641b9575ca.gif)

                看起来像是一个ScrollView，但是ScrollView上移的时候，上方的两行布局也会做相应的移动，总的来说效果还是相当不错的，那么我们就来尝试一下实现这个效果。

                &gt;分析布局

                - 1 首先，最外层是一个可以滚动的控件，那么就应该是ScrollView或者是ListView中的一种。而使用ListView理论上也可以实现该效果，但是对我来说使用比较简单的ScrollView会帮助我们跟加快的实现该效果。

                - 2 既然确定了最重要的控件，那么就需要来划分一下控件的层级。

                - 1 最内层与次内层分别为一个ViewGroup，并依此竖直排列。
                - 2 最外层是一个ScrollView，而其中包括的子ViewGroup的PaddingTop = (最内层高度 + 次内层高度)

                有了这些东西我们就可以首先实现我们的ViewGroup并复写onLayout方法来实现界面的初始化布局。


                &gt;实现布局

                首先我们的ViewGroup会通过onMeasure方法来测量各个子控件的大小，随后我们在复写的onLayout方法实现简单的布局。
                ```
                //	代码随后贴上
                ```

                &gt; 获取滑动的反馈

                由于原生的ScrollView是无法在外部获取到当前滑动情况的反馈的，所以我们要自定义一个类去继承ScrollView并实现我们自己的接口，来获取当前滑动距离的回调结果。

                ```
                public class ExtScrollView extends ScrollView {
                /* 中间省略 */

                /* 我们定义的接口 */
                public interface ScrollViewListener {
                void onScrollChanged(ExtScrollView scrollViewEar, int x, int y, int oldx, int oldy);
                }

                /* 添加上设置接口对象的方法 */
                public void setScrollViewListener(ScrollViewListener mScrollViewListener) {
                this.mScrollViewListener = mScrollViewListener;
                }

                /* 复写onScrollChanged方法 */
                @Override
                protected void onScrollChanged(int x, int y, int oldx, int oldy) {
                super.onScrollChanged(x, y, oldx, oldy);
                if(mScrollViewListener != null) {
                mScrollViewListener.onScrollChanged(this, x, y, oldx, oldy);
                }
                }
                }
                ```


                随后我们便可以在我们自定义的ViewGroup中实现这个接口，并获取相应的回调结果。</column>
            <column name="html">&lt;p&gt;&lt;a href=&quot;http://zuimeia.com/&quot;&gt;最美应用&lt;/a&gt;是一款很Nice的App，会经常推荐很多不错的应用给你，在最近的更新后，应用的主页采用了视差滑动的效果，效果很不错，见下图：&lt;/p&gt;

                &lt;p&gt;&lt;img src=&quot;http://i2.tietuku.com/a818e9641b9575ca.gif&quot; alt=&quot;最美应用&quot; /&gt;&lt;/p&gt;

                &lt;p&gt;看起来像是一个ScrollView，但是ScrollView上移的时候，上方的两行布局也会做相应的移动，总的来说效果还是相当不错的，那么我们就来尝试一下实现这个效果。&lt;/p&gt;

                &lt;blockquote&gt;
                &lt;p&gt;分析布局&lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;ul&gt;
                &lt;li&gt;&lt;p&gt;1 首先，最外层是一个可以滚动的控件，那么就应该是ScrollView或者是ListView中的一种。而使用ListView理论上也可以实现该效果，但是对我来说使用比较简单的ScrollView会帮助我们跟加快的实现该效果。&lt;/p&gt;&lt;/li&gt;
                &lt;li&gt;&lt;p&gt;2 既然确定了最重要的控件，那么就需要来划分一下控件的层级。&lt;/p&gt;

                &lt;ul&gt;&lt;li&gt;1 最内层与次内层分别为一个ViewGroup，并依此竖直排列。&lt;/li&gt;
                &lt;li&gt;2 最外层是一个ScrollView，而其中包括的子ViewGroup的PaddingTop = (最内层高度 + 次内层高度)&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
                &lt;/ul&gt;

                &lt;p&gt;有了这些东西我们就可以首先实现我们的ViewGroup并复写onLayout方法来实现界面的初始化布局。&lt;/p&gt;

                &lt;blockquote&gt;
                &lt;p&gt;实现布局&lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;p&gt;首先我们的ViewGroup会通过onMeasure方法来测量各个子控件的大小，随后我们在复写的onLayout方法实现简单的布局。&lt;/p&gt;

                &lt;pre&gt;&lt;code&gt;//    代码随后贴上
                &lt;/code&gt;&lt;/pre&gt;

                &lt;blockquote&gt;
                &lt;p&gt;获取滑动的反馈&lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;p&gt;由于原生的ScrollView是无法在外部获取到当前滑动情况的反馈的，所以我们要自定义一个类去继承ScrollView并实现我们自己的接口，来获取当前滑动距离的回调结果。&lt;/p&gt;

                &lt;pre&gt;&lt;code&gt;public class ExtScrollView extends ScrollView {
                /* 中间省略 */

                /* 我们定义的接口 */
                public interface ScrollViewListener {
                void onScrollChanged(ExtScrollView scrollViewEar, int x, int y, int oldx, int oldy);
                }

                /* 添加上设置接口对象的方法 */
                public void setScrollViewListener(ScrollViewListener mScrollViewListener) {
                this.mScrollViewListener = mScrollViewListener;
                }

                /* 复写onScrollChanged方法 */
                @Override
                protected void onScrollChanged(int x, int y, int oldx, int oldy) {
                super.onScrollChanged(x, y, oldx, oldy);
                if(mScrollViewListener != null) {
                mScrollViewListener.onScrollChanged(this, x, y, oldx, oldy);
                }
                }
                }
                &lt;/code&gt;&lt;/pre&gt;

                &lt;p&gt;随后我们便可以在我们自定义的ViewGroup中实现这个接口，并获取相应的回调结果。&lt;/p&gt;</column>
            <column name="image">NULL</column>
            <column name="featured">0</column>
            <column name="page">0</column>
            <column name="status">published</column>
            <column name="language">en_US</column>
            <column name="meta_title">NULL</column>
            <column name="meta_description">NULL</column>
            <column name="author_id">1</column>
            <column name="created_at">2015-04-13 14:24:36</column>
            <column name="created_by">1</column>
            <column name="updated_at">2015-04-14 13:47:08</column>
            <column name="updated_by">1</column>
            <column name="published_at">2015-04-13 14:24:40</column>
            <column name="published_by">1</column>
        </table>
        <table name="posts">
            <column name="id">23</column>
            <column name="uuid">bd3150b3-8b9c-4909-aca5-fec24073d7a8</column>
            <column name="title">将项目快速从Activity改变为Fragment</column>
            <column name="slug">jiang-xiang-mu-kuai-su-cong-activitygai-bian-wei-fragment</column>
            <column name="markdown">目前手头上有一个把原有手机平台的项目迁移至平板版本的需求，而原先手机版本是其他人编写的代码，含有N多Activity，如果逐一的修改每个Activity并把其改变继承自Fragment的类，再去修改onCreateView()等种种方法必然是一个麻烦的苦差事，既没有任何技术可言，又要考虑诸多的一些额外情况，所以就不得不想出来了另外一个方法。


                &gt;一般情况下Activity的创建方法

                一般情况下，我们创建一个Activity无非是新建一个Class，令其继承Activity或Activity的其他子类，实现其中的生命周期方法。并在**onCreate()**里面通过**setContentView()**方法设置布局文件，调用**findViewById()**方法完成控件的绑定，一个Activity就这么差不多实现了。


                而Fragment的声明周期呢？借用一下大家可能很熟悉的图片
                ![Fragment生命周期](http://img.my.csdn.net/uploads/201301/22/1358840998_2990.png)

                而通过与Activity声明周期的对比我们发现，几乎可以说是相较于Activity而言多了几个阶段：
                **onAttach()**，**onCreateView()**，**onActivityCreated()**，**onDestroyView()**，**onDetach()**。


                所以我们是否可以通过Fragment的声明周期去覆盖一个Activity的生命周期呢？


                &gt;尝试一下

                假设我们现在更改了一个现有的Activity让他继承自了Fragment，可能会发现如下的问题：
                ![修改后的'Activity'](http://i2.tietuku.com/cbaaacadbb68cb53.png)

                而onCreate()方法由于算是直接复写了Fragment中的onCreate()方法，所以该方法能够正常的在Fragment的声明周期中被调用。

                那么问题来了：我们可不可以实现自己的一个类继承Fragment，并实现我们需要的方法？

                肯定是可以的啊。

                &gt;自定义转换类Inverter

                ![](http://i2.tietuku.com/4eb7f8b00b88c1e0.png)

                其中mRoot是一个View对象，用于标识我们的Fragment的布局对象。

                这样，再令你的原Activity类继承自Inverter类就不会出现红色报错的情况了。

                但是这样就完了吗？肯定没有...

                &gt;更加重要的问题Activity的切换，传值

                在原先项目中使用Activity我们调用**startActivity()**方法或是**startActivityForResult()**方法可谓是必须的。

                那么既然我们需要把这一串的Activity项目的大部分全部改为Fragment，自然是不能通过startActivity来实现Fragment的切换的啊，而且fragment是实现了startActivity()以及startActivityForResult()方法的，那么我们不就可以通过复写这些方法，让他改变为Fragment的add，remove，操作岂不成了？

                - 1 首先我们来复写startActivity方法

                startActivity接受一个Intent类型的对象作为参数，而Intent对象最重要的就是其中含有了要打开的对象的class命，以及携带的Bundle类型的传递用参数。

                如何通过类名来实例化Fragment对象呢，当然是用反射，不过Fragment中已经有了通过String类型的类名获取实例对象的方法，就不需要我们再次编写代码了。

                而关于通过Intent对象传递值，我们通过查看Intent中一系列的PutExtra方法，发现Intent中将所有的值都存储在了一个名为extra的Bundle类型的对象中，那么就简单了。

                我们通过Intent的getExtras()方法直接获取Bundle对象，并在刚刚生成的新Fragment对象中调用setArguments()方法将Bundle对象快速传递至新的Fragment中去：
                ![](http://i2.tietuku.com/7a390f933ec3f025.png)
                其中**InverterController**是我定义的接口，用于让你的总Activity实现，来控制你的Fragment，其实改为一个继承Activity的类会更好，因为你还要实现一些变量，如Stack对象来维护你的Fragment栈，但这样可能会减少可控性。


                随后我们原先是通过getIntent()来获取Activity之间传递的Intent对象，于是我们也需要在Inverter类中实现getIntent()方法。
                ![](http://i2.tietuku.com/38df6e26b802c8fb.png)
                这这不用判断我们的bundle是否为null因为Intent的getExtras()方法已经为我们做了相应的判断了~
                &gt;如何实现Fragment的切换与数据的交互

                通常我们会用setResult()方法来传递Activity的结果给原先的Activity，随后调用finish()方法结束掉Activity，系统会自动的将结果送入原Activity的onActivityResult()方法中去处理，而我们同样也可以模仿这个过程，实现Fragment之间的数据传递。


                待续~
            </column>
            <column name="html">&lt;p&gt;目前手头上有一个把原有手机平台的项目迁移至平板版本的需求，而原先手机版本是其他人编写的代码，含有N多Activity，如果逐一的修改每个Activity并把其改变继承自Fragment的类，再去修改onCreateView()等种种方法必然是一个麻烦的苦差事，既没有任何技术可言，又要考虑诸多的一些额外情况，所以就不得不想出来了另外一个方法。&lt;/p&gt;

                &lt;blockquote&gt;
                &lt;p&gt;一般情况下Activity的创建方法&lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;p&gt;一般情况下，我们创建一个Activity无非是新建一个Class，令其继承Activity或Activity的其他子类，实现其中的生命周期方法。并在&lt;strong&gt;onCreate()&lt;/strong&gt;里面通过&lt;strong&gt;setContentView()&lt;/strong&gt;方法设置布局文件，调用&lt;strong&gt;findViewById()&lt;/strong&gt;方法完成控件的绑定，一个Activity就这么差不多实现了。&lt;/p&gt;

                &lt;p&gt;而Fragment的声明周期呢？借用一下大家可能很熟悉的图片
                &lt;img src=&quot;http://img.my.csdn.net/uploads/201301/22/1358840998_2990.png&quot; alt=&quot;Fragment生命周期&quot; /&gt;&lt;/p&gt;

                &lt;p&gt;而通过与Activity声明周期的对比我们发现，几乎可以说是相较于Activity而言多了几个阶段：
                &lt;strong&gt;onAttach()&lt;/strong&gt;，&lt;strong&gt;onCreateView()&lt;/strong&gt;，&lt;strong&gt;onActivityCreated()&lt;/strong&gt;，&lt;strong&gt;onDestroyView()&lt;/strong&gt;，&lt;strong&gt;onDetach()&lt;/strong&gt;。&lt;/p&gt;

                &lt;p&gt;所以我们是否可以通过Fragment的声明周期去覆盖一个Activity的生命周期呢？&lt;/p&gt;

                &lt;blockquote&gt;
                &lt;p&gt;尝试一下&lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;p&gt;假设我们现在更改了一个现有的Activity让他继承自了Fragment，可能会发现如下的问题：
                &lt;img src=&quot;http://i2.tietuku.com/cbaaacadbb68cb53.png&quot; alt=&quot;修改后的'Activity'&quot; /&gt;&lt;/p&gt;

                &lt;p&gt;而onCreate()方法由于算是直接复写了Fragment中的onCreate()方法，所以该方法能够正常的在Fragment的声明周期中被调用。&lt;/p&gt;

                &lt;p&gt;那么问题来了：我们可不可以实现自己的一个类继承Fragment，并实现我们需要的方法？&lt;/p&gt;

                &lt;p&gt;肯定是可以的啊。&lt;/p&gt;

                &lt;blockquote&gt;
                &lt;p&gt;自定义转换类Inverter&lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;p&gt;&lt;img src=&quot;http://i2.tietuku.com/4eb7f8b00b88c1e0.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

                &lt;p&gt;其中mRoot是一个View对象，用于标识我们的Fragment的布局对象。&lt;/p&gt;

                &lt;p&gt;这样，再令你的原Activity类继承自Inverter类就不会出现红色报错的情况了。&lt;/p&gt;

                &lt;p&gt;但是这样就完了吗？肯定没有...&lt;/p&gt;

                &lt;blockquote&gt;
                &lt;p&gt;更加重要的问题Activity的切换，传值&lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;p&gt;在原先项目中使用Activity我们调用&lt;strong&gt;startActivity()&lt;/strong&gt;方法或是&lt;strong&gt;startActivityForResult()&lt;/strong&gt;方法可谓是必须的。&lt;/p&gt;

                &lt;p&gt;那么既然我们需要把这一串的Activity项目的大部分全部改为Fragment，自然是不能通过startActivity来实现Fragment的切换的啊，而且fragment是实现了startActivity()以及startActivityForResult()方法的，那么我们不就可以通过复写这些方法，让他改变为Fragment的add，remove，操作岂不成了？&lt;/p&gt;

                &lt;ul&gt;
                &lt;li&gt;1 首先我们来复写startActivity方法&lt;/li&gt;
                &lt;/ul&gt;

                &lt;p&gt;startActivity接受一个Intent类型的对象作为参数，而Intent对象最重要的就是其中含有了要打开的对象的class命，以及携带的Bundle类型的传递用参数。&lt;/p&gt;

                &lt;p&gt;如何通过类名来实例化Fragment对象呢，当然是用反射，不过Fragment中已经有了通过String类型的类名获取实例对象的方法，就不需要我们再次编写代码了。&lt;/p&gt;

                &lt;p&gt;而关于通过Intent对象传递值，我们通过查看Intent中一系列的PutExtra方法，发现Intent中将所有的值都存储在了一个名为extra的Bundle类型的对象中，那么就简单了。&lt;/p&gt;

                &lt;p&gt;我们通过Intent的getExtras()方法直接获取Bundle对象，并在刚刚生成的新Fragment对象中调用setArguments()方法将Bundle对象快速传递至新的Fragment中去：
                &lt;img src=&quot;http://i2.tietuku.com/7a390f933ec3f025.png&quot; alt=&quot;&quot; /&gt;
                其中&lt;strong&gt;InverterController&lt;/strong&gt;是我定义的接口，用于让你的总Activity实现，来控制你的Fragment，其实改为一个继承Activity的类会更好，因为你还要实现一些变量，如Stack对象来维护你的Fragment栈，但这样可能会减少可控性。&lt;/p&gt;

                &lt;p&gt;随后我们原先是通过getIntent()来获取Activity之间传递的Intent对象，于是我们也需要在Inverter类中实现getIntent()方法。
                &lt;img src=&quot;http://i2.tietuku.com/38df6e26b802c8fb.png&quot; alt=&quot;&quot; /&gt;
                这这不用判断我们的bundle是否为null因为Intent的getExtras()方法已经为我们做了相应的判断了~&lt;/p&gt;

                &lt;blockquote&gt;
                &lt;p&gt;如何实现Fragment的切换与数据的交互&lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;p&gt;通常我们会用setResult()方法来传递Activity的结果给原先的Activity，随后调用finish()方法结束掉Activity，系统会自动的将结果送入原Activity的onActivityResult()方法中去处理，而我们同样也可以模仿这个过程，实现Fragment之间的数据传递。&lt;/p&gt;

                &lt;p&gt;待续~&lt;/p&gt;</column>
            <column name="image">NULL</column>
            <column name="featured">0</column>
            <column name="page">0</column>
            <column name="status">published</column>
            <column name="language">en_US</column>
            <column name="meta_title">NULL</column>
            <column name="meta_description">NULL</column>
            <column name="author_id">1</column>
            <column name="created_at">2015-04-16 08:32:49</column>
            <column name="created_by">1</column>
            <column name="updated_at">2015-04-16 09:24:12</column>
            <column name="updated_by">1</column>
            <column name="published_at">2015-04-16 08:34:03</column>
            <column name="published_by">1</column>
        </table>
        <table name="posts">
            <column name="id">24</column>
            <column name="uuid">b6ca4a22-cffa-4a68-8cb9-7bd632ab650c</column>
            <column name="title">Android SwipeRefreshLayout 源码简单分析</column>
            <column name="slug">android-swiperefreshlayout-yuan-ma-jian-dan-fen-xi</column>
            <column name="markdown">&gt;看一下相关几个方法或类的源码


                - ViewCompat.canScrollVertically(target, -1)
                - MaterialProgressDrawable
                - CircleImageView
                - MotionEventCompat.getActionMasked(ev)

                &gt;深入分析事件传递的机制

                - 比如第一次如果DOWN事件没有对象处理则不进行MOVE事件的Dispatch处理
                - requestDisallowInterceptTouchEvent() 方法的用途，位于事件处理周期的作用
                - 一般情况下复写ViewGroup对于事件传递的控制是采用复写onInterceptTouchEvent()还是dispatchTouchEvent()?</column>
            <column name="html">&lt;blockquote&gt;
                &lt;p&gt;看一下相关几个方法或类的源码&lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;ul&gt;
                &lt;li&gt;ViewCompat.canScrollVertically(target, -1)&lt;/li&gt;
                &lt;li&gt;MaterialProgressDrawable&lt;/li&gt;
                &lt;li&gt;CircleImageView &lt;/li&gt;
                &lt;li&gt;MotionEventCompat.getActionMasked(ev)&lt;/li&gt;
                &lt;/ul&gt;

                &lt;blockquote&gt;
                &lt;p&gt;深入分析事件传递的机制 &lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;ul&gt;
                &lt;li&gt;比如第一次如果DOWN事件没有对象处理则不进行MOVE事件的Dispatch处理&lt;/li&gt;
                &lt;li&gt;requestDisallowInterceptTouchEvent() 方法的用途，位于事件处理周期的作用&lt;/li&gt;
                &lt;li&gt;一般情况下复写ViewGroup对于事件传递的控制是采用复写onInterceptTouchEvent()还是dispatchTouchEvent()?&lt;/li&gt;
                &lt;/ul&gt;</column>
            <column name="image">NULL</column>
            <column name="featured">0</column>
            <column name="page">0</column>
            <column name="status">published</column>
            <column name="language">en_US</column>
            <column name="meta_title">NULL</column>
            <column name="meta_description">NULL</column>
            <column name="author_id">1</column>
            <column name="created_at">2015-04-17 11:28:22</column>
            <column name="created_by">1</column>
            <column name="updated_at">2015-04-17 11:42:46</column>
            <column name="updated_by">1</column>
            <column name="published_at">2015-04-17 11:28:22</column>
            <column name="published_by">1</column>
        </table>
        <table name="posts">
            <column name="id">25</column>
            <column name="uuid">8da7abdd-bb3a-4548-829d-eea342933ac5</column>
            <column name="title">实现Google Play 的 ViewPager 指示器效果</column>
            <column name="slug">shi-xian-google-play-de-viewpager-zhi-shi-qi-xiao-guo</column>
            <column name="markdown">- ViewParent
                - setWillNotDraw(false)[leehong2005的Blog](http://blog.csdn.net/leehong2005/article/details/7299471)
                - delay
                - onPagerScroll
                - v13 FragmentPagerAdapter [StackOverFlow](http://stackoverflow.com/questions/13501424/fragmentpageradapter-exists-only-in-android-support-v4-app-and-not-android-app)
                - 直接指定子View的大小
                - android-support-annotations</column>
            <column name="html">&lt;ul&gt;
                &lt;li&gt;ViewParent&lt;/li&gt;
                &lt;li&gt;setWillNotDraw(false)&lt;a href=&quot;http://blog.csdn.net/leehong2005/article/details/7299471&quot;&gt;leehong2005的Blog&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;delay&lt;/li&gt;
                &lt;li&gt;onPagerScroll&lt;/li&gt;
                &lt;li&gt;v13 FragmentPagerAdapter &lt;a href=&quot;http://stackoverflow.com/questions/13501424/fragmentpageradapter-exists-only-in-android-support-v4-app-and-not-android-app&quot;&gt;StackOverFlow&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;直接指定子View的大小&lt;/li&gt;
                &lt;li&gt;android-support-annotations&lt;/li&gt;
                &lt;/ul&gt;</column>
            <column name="image">NULL</column>
            <column name="featured">0</column>
            <column name="page">0</column>
            <column name="status">published</column>
            <column name="language">en_US</column>
            <column name="meta_title">NULL</column>
            <column name="meta_description">NULL</column>
            <column name="author_id">1</column>
            <column name="created_at">2015-04-21 11:05:35</column>
            <column name="created_by">1</column>
            <column name="updated_at">2015-04-22 08:26:42</column>
            <column name="updated_by">1</column>
            <column name="published_at">2015-04-21 11:05:35</column>
            <column name="published_by">1</column>
        </table>
        <table name="posts">
            <column name="id">26</column>
            <column name="uuid">e879ae9f-6b8b-4f67-8207-6c9c1df909ca</column>
            <column name="title">DragTopLayout 的分析与学习 （一）</column>
            <column name="slug">dragtoplayout-de-fen-xi-yu-xue-xi</column>
            <column name="markdown"></column>
            <column name="html"></column>
            <column name="image">NULL</column>
            <column name="featured">0</column>
            <column name="page">0</column>
            <column name="status">published</column>
            <column name="language">en_US</column>
            <column name="meta_title">NULL</column>
            <column name="meta_description">NULL</column>
            <column name="author_id">1</column>
            <column name="created_at">2015-04-23 16:31:01</column>
            <column name="created_by">1</column>
            <column name="updated_at">2015-04-23 16:31:01</column>
            <column name="updated_by">1</column>
            <column name="published_at">2015-04-23 16:31:01</column>
            <column name="published_by">1</column>
        </table>
        <table name="posts">
            <column name="id">27</column>
            <column name="uuid">7d98848a-757e-4a8a-9ca8-61bdb756d743</column>
            <column name="title">Android项目中使用Netty来实现Socket长连接</column>
            <column name="slug">androidxiang-mu-zhong-shi-yong-nettylai-shi-xian-socketchang-lian-jie</column>
            <column name="markdown">特别感谢 [远方夕阳 / cim](http://git.oschina.net/farsunset/cim/tree/master/cim_for_netty/mchat-simple) 的开源IM项目，借鉴了其中大量的代码，也让我对Netty的工作方式有了更好地理解，&lt;del&gt;其实之前就根本不理解吧...&lt;/del&gt;


                &gt; 首选我们先看一看Java中最简单的Socket工作方式
                ![](http://pic002.cnblogs.com/images/2012/367859/2012011916104438.gif)

                - **服务端**

                - 1 用 ServerSocket来监听本地的某个端口。
                - 2 调用 ServerSocket对象的accept()来获取连接到的Socket对象。
                - 3 线程阻塞在上面一行代码直到有Socket连接，代码继续运行。
                - 4 从Socket中获取输入流*InputStream*与输出流*OutputStream*来获得收到的与发出信息的流。
                - 5 从流中发送数据或者提取数据，好比从流水中取出在上面漂浮的小船。
                - 6 关闭Socket。

                - **客户端**
                - 1 指定Socket要连接的地址与端口号，连接成功后返回Socket对象否则抛出超时异常。
                - 2 同服务端的获取两个流，注意此时服务端的流出的流流向你就相当于你接受的流，也就是服务端的OutputStream 可以理解为 直接传输到你的 InputStream， 反之同理。
                - 3 从流中发送数据或读取数据。
                - 4 关闭连接。

                **数据传递的方式见下图**
                ![Socket数据传输的方式](http://www.2cto.com/uploadfile/Collfiles/20140705/20140705092321205.png)

                如果服务器要处理多个连接，就在一个线程中不断的执行accept()方法，并将返回的Scoket对象送入一个新的线程来处理与该对象的通信。

                &gt;NIO的工作方式

                关于NIO的原理与方式这篇博文讲的非常清楚[Java NIO原理 图文分析及代码实现](http://weixiaolu.iteye.com/blog/1479656)。

                其中最主要的概念就是**Selector**与**Channel**，下面就说说我浅显的理解，也可能有误，请大家指正。

                - **Selector**

                让我们看看之前的Socket工作方式，不管是ServerSocket或者Socket，我们都必须在某一时刻阻塞自己去等待，想象一下，假如你是Socket，此时让你等待某个人前来找你，所以你就必须在家里等呀等呀等呀，初次之外你什么也不能干，就只能在这耗着，而且为了保证你能专心的等，还必须为你单独分配一个“等待小屋”来让你有地方等待他，好不容易等到了，你也就认识了一下他，随后就留了一下彼此的手机号，就把他分到你的新盖的客厅里面了，然后你又继续等待下一个人...

                这种方式显然是不太科学的，因为大多数时间你不需要只等，而且也没必要为每一个客人单独分配一个房间(*线程*)，也是资源上的浪费。

                你现在想要等客人。

                &lt;code&gt;ServerSocketChannel serverChannel = ServerSocketChannel.open()&lt;/code&gt;

                但是又不想费时间等待。

                &lt;code&gt;serverChannel.configureBlocking(false)&lt;/code&gt;

                所以你雇了一个管家（*Selector*）。

                &lt;code&gt;selector = Selector.open();&lt;/code&gt;

                你要等你的端口XXX的人。

                &lt;code&gt;serverChannel.socket().bind(new InetSocketAddress(port));&lt;/code&gt;

                你告诉他，我有客人要来，有人来你就通知我行不？

                &lt;code&gt;serverChannel.register(selector, SelectionKey.OP_ACCEPT);&lt;/code&gt;

                随后这个管家就在这等待，但凡有满足当时对他要求的对象，那么就取出来进行处理，他会告诉你，有你等待的人了。

                而下面代码中的Selector对象实质上维护了一个我们注册过的事件的集合，每当有任何满足注册条件的事件发生时，我们去遍历满足的key的集合，再分别判断是哪个事件就可以进行进一步的处理了。

                ```
                while (true) {
                //当注册的事件到达时，方法返回；否则,该方法会一直阻塞
                selector.select();
                // 获得selector中选中的项的迭代器，选中的项为注册的事件
                Iterator ite = this.selector.selectedKeys().iterator();
                while (ite.hasNext()) {
                SelectionKey key = (SelectionKey) ite.next();
                // 删除已选的key,以防重复处理
                ite.remove();
                // 客户端请求连接事件
                if (key.isAcceptable()) {
                ServerSocketChannel server = (ServerSocketChannel) key.channel();
                // 获得和客户端连接的通道
                SocketChannel channel = server.accept();
                // 设置成非阻塞
                channel.configureBlocking(false);
                //在这里可以给客户端发送信息哦
                channel.write(ByteBuffer.wrap(new String(&quot;向客户端发送了一条信息&quot;).getBytes()));
                //在和客户端连接成功之后，为了可以接收到客户端的信息，需要给通道设置读的权限。
                channel.register(this.selector, SelectionKey.OP_READ);
                // 获得了可读的事件
                } else if (key.isReadable()) {
                read(key);
                }
                }
                }
                ```


                注意上方的代码，从socketChannel对象中调用accept()方法获取了SocketChannel对象，并且同样为其注册了SelectionKey.OP_READ到刚刚的管家（*Selector*）对象上去。

                随后当Selector继续select()事件，当属于readdable()事件的时候变进行相应的读取处理。


                而对于客户端来说，首先我们需要将SocketChannel打开并设置为非阻塞，同样也为其注册SelectionKey.OP_CONNECT事件到Selector上去。

                需要住的是，我们需要先调用SocketChamnel对象的connect()方法去连接服务器，但是该方法不会阻塞，而且并不能完成一次完整的连接，需要我们捕捉到SocketChannel对象isConnectable()的时候继续调用SocketChannel对象的finishConnect()方法才能完成连接。


                &gt;采用Netty实现NIO Socket连接

                首先我们先来了解一下JAVA内线程池的一些概念与方法 [java自带线程池和队列详细讲解](http://www.oschina.net/question/565065_86540)

                下面我们直接来看CIM项目中Android部分的代码。

                ```
                class CIMConnectorManager  {

                /* 单例模式实例 */
                private static CIMConnectorManager manager;

                /* Netty中的SocketChannel */
                private Channel channel;

                /* Netty中的启动器用于管理Channel的各个线程 */
                private ClientBootstrap bootstrap;

                private Context context;

                /* Java中的线程池管理对象 */
                private ExecutorService executor;

                /* 首先是单例模式获取ConnectorManager实例 */
                public synchronized static CIMConnectorManager getManager(Context context) {
                if (manager == null) {
                manager = new CIMConnectorManager(context);
                }
                return manager;
                }

                private CIMConnectorManager(Context ctx) {
                context = ctx;

                /* 建立一个固定大小3的线程池 详细内容见上方的连接 */
                executor = Executors.newFixedThreadPool(3);

                /** 初始化启动器 启动器接受一个ChannelFactory对象
                *此处我们采用了NIO方式的ChannelFactory
                *并且为其中的Boss与Worker线程池管理对象传递了一个不固定大小的线程池
                */
                bootstrap = new ClientBootstrap(new NioClientSocketChannelFactory(
                Executors.newCachedThreadPool(),
                Executors.newCachedThreadPool()));

                /** 随后为启动器设置了ChannelPipeLineFactory
                *目的是对channel进行数据的处理与编码与解码操作
                */
                bootstrap.setPipelineFactory(new ChannelPipelineFactory() {
                public ChannelPipeline getPipeline() throws Exception {
                return Channels.pipeline(
                new ClientMessageDecoder(),
                new ClientMessageEncoder(),
                channelUpstreamHandler);
                }
                });
                }

                /* 利用synchronized关键字声明连接方法 并获取连接后的类SocketChannel对象*/
                private synchronized void syncConnection(final String cimServerHost,final int cimServerPort) {
                try {
                if(isConnected()){
                return ;
                }
                channel  = bootstrap.connect(new InetSocketAddress(cimServerHost, cimServerPort)).getChannel(); //这里的IP和端口，根据自己情况修改
                } catch (Exception e) {
                Intent intent = new Intent();
                intent.setAction(ACTION_CONNECTION_FAILED);
                intent.putExtra(&quot;exception&quot;, e);
                context.sendBroadcast(intent);
                System.out.println(&quot;******************CIM连接服务器失败  &quot;+cimServerHost+&quot;:&quot;+cimServerPort);
                }
                }

                /* 外部可以调用的连接方法 */
                public  void connect(final String cimServerHost, final int cimServerPort) {
                /* 首先判断网络连接是否可用 */
                if (!netWorkAvailable(context)) {
                Intent intent = new Intent();
                intent.setAction(ACTION_CONNECTION_FAILED);
                intent.putExtra(&quot;exception&quot;, new NetWorkDisableException());
                context.sendBroadcast(intent);
                return;
                }
                /** 往线程池中提交任务，并捕捉返回的结果
                *也就实质上上方的syncConnection()方法是在子线程中执行的。
                *并且判断线程执行的结果，如果没有连接成功则继续调用本身继续连接。
                */
                Future&lt;?&gt; future = executor.submit(new Runnable() {
                @Override
                public void run() {
                syncConnection(cimServerHost, cimServerPort);
                }
                });
                try {
                if(future.get()!=null){
                connect(cimServerHost,cimServerPort);
                }
                } catch (Exception e) {
                connect(cimServerHost,cimServerPort);
                e.printStackTrace();
                }
                }

                /* 下面是比较重要的Handler也就是在这处理Channel的各种事件 */
                SimpleChannelUpstreamHandler channelUpstreamHandler = new SimpleChannelUpstreamHandler() {

                @Override
                public void channelConnected( ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {
                System.out.println(&quot;******************CIM连接服务器成功:&quot;+ctx.getChannel().getLocalAddress());
                Intent intent = new Intent();
                intent.setAction(ACTION_CONNECTION_SUCCESS);
                context.sendBroadcast(intent);
                }

                @Override
                public void channelClosed(ChannelHandlerContext ctx, ChannelStateEvent event) throws Exception {
                System.out.println(&quot;******************CIM与服务器断开连接:&quot;+ctx.getChannel().getLocalAddress());
                if(channel.getId()==ctx.getChannel().getId()){
                Intent intent = new Intent();
                intent.setAction(ACTION_CONNECTION_CLOSED);
                context.sendBroadcast(intent);
                }
                }

                @Override
                public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e)
                throws Exception {
                Intent intent = new Intent();
                intent.setAction(ACTION_UNCAUGHT_EXCEPTION);
                intent.putExtra(&quot;exception&quot;, e.getCause());
                context.sendBroadcast(intent);
                }

                @Override
                public void messageReceived(ChannelHandlerContext ctx, MessageEvent event)throws Exception {
                if (event.getMessage() instanceof Message) {
                Intent intent = new Intent();
                intent.setAction(ACTION_MESSAGE_RECEIVED);
                intent.putExtra(&quot;message&quot;, (Message) event.getMessage());
                context.sendBroadcast(intent);
                }
                if (event.getMessage() instanceof ReplyBody) {
                Intent intent = new Intent();
                intent.setAction(ACTION_REPLY_RECEIVED);
                intent.putExtra(&quot;replyBody&quot;, (ReplyBody) event.getMessage());
                context.sendBroadcast(intent);
                }
                }

                @Override
                public void writeComplete(ChannelHandlerContext ctx, WriteCompletionEvent event) throws Exception {
                Intent intent = new Intent();
                intent.setAction(ACTION_SENT_SUCCESS);
                //intent.putExtra(&quot;sentBody&quot;, null);
                context.sendBroadcast(intent);
                }
                };

                /** 接下来是发送数据的方法 同样的也是送给线程池去执行发送操作
                *值得注意的是Channel无论是发送还是接受，所得到的对象均为ChannelBuffer
                *ChannelBuffer可以理解为类似ByteBuffer的缓冲字节管理对象
                *我们在接受数据与发送数据的时候均需要把数据放入或从ChannelBuffer中取出
                *进而转化为我们想要的数据
                */
                public void send(final SentBody body) {
                executor.execute(new Runnable() {
                @Override
                public void run() {
                android.os.Message msg = new android.os.Message();
                msg.getData().putSerializable(&quot;body&quot;, body);
                if(channel!=null &amp;&amp; channel.isConnected()){
                boolean  isDone = channel.write(body).awaitUninterruptibly(5000);
                if (!isDone) {
                Intent intent = new Intent();
                intent.setAction(ACTION_SENT_FAILED);
                intent.putExtra(&quot;exception&quot;, new WriteToClosedSessionException());
                intent.putExtra(&quot;sentBody&quot;, body);
                context.sendBroadcast(intent);
                }
                }else{
                Intent intent = new Intent();
                intent.setAction(ACTION_SENT_FAILED);
                intent.putExtra(&quot;exception&quot;, new CIMSessionDisableException());
                intent.putExtra(&quot;sentBody&quot;, body);
                context.sendBroadcast(intent);
                }
                }
                });
                }
                }
                ```

                以上就是Netty在Android项目中使用的主要代码，具体的代码可以到文章开头的连接中去寻找原作者的Android IM 项目源码，也值得我们去学习与分析。

                而关于Netty中比较重要的几个概念就是**Boss， Worker， PipeLine，ChannelBuffer**

                - 关于Boss, Worker的请查看[Netty多线程处理机制  ](http://blog.163.com/linfenliang@126/blog/static/127857195201210744448686/?suggestedreading)这篇博文的介绍
                - 关于PipeLine可以单纯的理解为数据从接受到抓化为你想要的数据，或者从发送的原始对象抓化为相应的数据帧的一个封装与解封装的一个过程，发送的数据会通过一层一层的Encode去发送或者是包装，相应的接收到的数据会一层一层的Decode来转化与解析。
                - ChannelBuffer是Channel发送数据与接收数据的原始对象，当你从handler的Receiver接口中读取到MessageEvent独享的时候， 如果没有额外的Decode那么返回的就是原始的ChannelBuffer对象</column>
            <column name="html">&lt;p&gt;特别感谢 &lt;a href=&quot;http://git.oschina.net/farsunset/cim/tree/master/cim_for_netty/mchat-simple&quot;&gt;远方夕阳 / cim&lt;/a&gt; 的开源IM项目，借鉴了其中大量的代码，也让我对Netty的工作方式有了更好地理解，&lt;del&gt;其实之前就根本不理解吧...&lt;/del&gt;&lt;/p&gt;

                &lt;blockquote&gt;
                &lt;p&gt;首选我们先看一看Java中最简单的Socket工作方式
                &lt;img src=&quot;http://pic002.cnblogs.com/images/2012/367859/2012011916104438.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;ul&gt;
                &lt;li&gt;&lt;p&gt;&lt;strong&gt;服务端&lt;/strong&gt;&lt;/p&gt;

                &lt;ul&gt;&lt;li&gt;1 用 ServerSocket来监听本地的某个端口。&lt;/li&gt;
                &lt;li&gt;2 调用 ServerSocket对象的accept()来获取连接到的Socket对象。&lt;/li&gt;
                &lt;li&gt;3 线程阻塞在上面一行代码直到有Socket连接，代码继续运行。&lt;/li&gt;
                &lt;li&gt;4 从Socket中获取输入流&lt;em&gt;InputStream&lt;/em&gt;与输出流&lt;em&gt;OutputStream&lt;/em&gt;来获得收到的与发出信息的流。&lt;/li&gt;
                &lt;li&gt;5 从流中发送数据或者提取数据，好比从流水中取出在上面漂浮的小船。&lt;/li&gt;
                &lt;li&gt;6 关闭Socket。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
                &lt;li&gt;&lt;p&gt;&lt;strong&gt;客户端&lt;/strong&gt;&lt;/p&gt;

                &lt;ul&gt;&lt;li&gt;1 指定Socket要连接的地址与端口号，连接成功后返回Socket对象否则抛出超时异常。&lt;/li&gt;
                &lt;li&gt;2 同服务端的获取两个流，注意此时服务端的流出的流流向你就相当于你接受的流，也就是服务端的OutputStream 可以理解为 直接传输到你的 InputStream， 反之同理。&lt;/li&gt;
                &lt;li&gt;3 从流中发送数据或读取数据。&lt;/li&gt;
                &lt;li&gt;4 关闭连接。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
                &lt;/ul&gt;

                &lt;p&gt;&lt;strong&gt;数据传递的方式见下图&lt;/strong&gt;
                &lt;img src=&quot;http://www.2cto.com/uploadfile/Collfiles/20140705/20140705092321205.png&quot; alt=&quot;Socket数据传输的方式&quot; /&gt;&lt;/p&gt;

                &lt;p&gt;如果服务器要处理多个连接，就在一个线程中不断的执行accept()方法，并将返回的Scoket对象送入一个新的线程来处理与该对象的通信。&lt;/p&gt;

                &lt;blockquote&gt;
                &lt;p&gt;NIO的工作方式&lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;p&gt;关于NIO的原理与方式这篇博文讲的非常清楚&lt;a href=&quot;http://weixiaolu.iteye.com/blog/1479656&quot;&gt;Java NIO原理 图文分析及代码实现&lt;/a&gt;。&lt;/p&gt;

                &lt;p&gt;其中最主要的概念就是&lt;strong&gt;Selector&lt;/strong&gt;与&lt;strong&gt;Channel&lt;/strong&gt;，下面就说说我浅显的理解，也可能有误，请大家指正。&lt;/p&gt;

                &lt;ul&gt;
                &lt;li&gt;&lt;strong&gt;Selector&lt;/strong&gt;&lt;/li&gt;
                &lt;/ul&gt;

                &lt;p&gt;让我们看看之前的Socket工作方式，不管是ServerSocket或者Socket，我们都必须在某一时刻阻塞自己去等待，想象一下，假如你是Socket，此时让你等待某个人前来找你，所以你就必须在家里等呀等呀等呀，初次之外你什么也不能干，就只能在这耗着，而且为了保证你能专心的等，还必须为你单独分配一个“等待小屋”来让你有地方等待他，好不容易等到了，你也就认识了一下他，随后就留了一下彼此的手机号，就把他分到你的新盖的客厅里面了，然后你又继续等待下一个人...&lt;/p&gt;

                &lt;p&gt;这种方式显然是不太科学的，因为大多数时间你不需要只等，而且也没必要为每一个客人单独分配一个房间(&lt;em&gt;线程&lt;/em&gt;)，也是资源上的浪费。&lt;/p&gt;

                &lt;p&gt;你现在想要等客人。&lt;/p&gt;

                &lt;p&gt;&lt;code&gt;ServerSocketChannel serverChannel = ServerSocketChannel.open()&lt;/code&gt;&lt;/p&gt;

                &lt;p&gt;但是又不想费时间等待。&lt;/p&gt;

                &lt;p&gt;&lt;code&gt;serverChannel.configureBlocking(false)&lt;/code&gt;&lt;/p&gt;

                &lt;p&gt;所以你雇了一个管家（&lt;em&gt;Selector&lt;/em&gt;）。&lt;/p&gt;

                &lt;p&gt;&lt;code&gt;selector = Selector.open();&lt;/code&gt;&lt;/p&gt;

                &lt;p&gt;你要等你的端口XXX的人。&lt;/p&gt;

                &lt;p&gt;&lt;code&gt;serverChannel.socket().bind(new InetSocketAddress(port));&lt;/code&gt;&lt;/p&gt;

                &lt;p&gt;你告诉他，我有客人要来，有人来你就通知我行不？&lt;/p&gt;

                &lt;p&gt;&lt;code&gt;serverChannel.register(selector, SelectionKey.OP_ACCEPT);&lt;/code&gt;&lt;/p&gt;

                &lt;p&gt;随后这个管家就在这等待，但凡有满足当时对他要求的对象，那么就取出来进行处理，他会告诉你，有你等待的人了。&lt;/p&gt;

                &lt;p&gt;而下面代码中的Selector对象实质上维护了一个我们注册过的事件的集合，每当有任何满足注册条件的事件发生时，我们去遍历满足的key的集合，再分别判断是哪个事件就可以进行进一步的处理了。&lt;/p&gt;

                &lt;pre&gt;&lt;code&gt;        while (true) {
                //当注册的事件到达时，方法返回；否则,该方法会一直阻塞
                selector.select();
                // 获得selector中选中的项的迭代器，选中的项为注册的事件
                Iterator ite = this.selector.selectedKeys().iterator();
                while (ite.hasNext()) {
                SelectionKey key = (SelectionKey) ite.next();
                // 删除已选的key,以防重复处理
                ite.remove();
                // 客户端请求连接事件
                if (key.isAcceptable()) {
                ServerSocketChannel server = (ServerSocketChannel) key.channel();
                // 获得和客户端连接的通道
                SocketChannel channel = server.accept();
                // 设置成非阻塞
                channel.configureBlocking(false);
                //在这里可以给客户端发送信息哦
                channel.write(ByteBuffer.wrap(new String(&quot;向客户端发送了一条信息&quot;).getBytes()));
                //在和客户端连接成功之后，为了可以接收到客户端的信息，需要给通道设置读的权限。
                channel.register(this.selector, SelectionKey.OP_READ);
                // 获得了可读的事件
                } else if (key.isReadable()) {
                read(key);
                }
                }
                }
                &lt;/code&gt;&lt;/pre&gt;

                &lt;p&gt;注意上方的代码，从socketChannel对象中调用accept()方法获取了SocketChannel对象，并且同样为其注册了SelectionKey.OP_READ到刚刚的管家（&lt;em&gt;Selector&lt;/em&gt;）对象上去。&lt;/p&gt;

                &lt;p&gt;随后当Selector继续select()事件，当属于readdable()事件的时候变进行相应的读取处理。&lt;/p&gt;

                &lt;p&gt;而对于客户端来说，首先我们需要将SocketChannel打开并设置为非阻塞，同样也为其注册SelectionKey.OP_CONNECT事件到Selector上去。&lt;/p&gt;

                &lt;p&gt;需要住的是，我们需要先调用SocketChamnel对象的connect()方法去连接服务器，但是该方法不会阻塞，而且并不能完成一次完整的连接，需要我们捕捉到SocketChannel对象isConnectable()的时候继续调用SocketChannel对象的finishConnect()方法才能完成连接。&lt;/p&gt;

                &lt;blockquote&gt;
                &lt;p&gt;采用Netty实现NIO Socket连接&lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;p&gt;首先我们先来了解一下JAVA内线程池的一些概念与方法 &lt;a href=&quot;http://www.oschina.net/question/565065_86540&quot;&gt;java自带线程池和队列详细讲解&lt;/a&gt;&lt;/p&gt;

                &lt;p&gt;下面我们直接来看CIM项目中Android部分的代码。&lt;/p&gt;

                &lt;pre&gt;&lt;code&gt;class CIMConnectorManager  {

                /* 单例模式实例 */
                private static CIMConnectorManager manager;

                /* Netty中的SocketChannel */
                private Channel channel;

                /* Netty中的启动器用于管理Channel的各个线程 */
                private ClientBootstrap bootstrap;

                private Context context;

                /* Java中的线程池管理对象 */
                private ExecutorService executor;

                /* 首先是单例模式获取ConnectorManager实例 */
                public synchronized static CIMConnectorManager getManager(Context context) {
                if (manager == null) {
                manager = new CIMConnectorManager(context);
                }
                return manager;
                }

                private CIMConnectorManager(Context ctx) {
                context = ctx;

                /* 建立一个固定大小3的线程池 详细内容见上方的连接 */
                executor = Executors.newFixedThreadPool(3);

                /** 初始化启动器 启动器接受一个ChannelFactory对象
                *此处我们采用了NIO方式的ChannelFactory
                *并且为其中的Boss与Worker线程池管理对象传递了一个不固定大小的线程池
                */
                bootstrap = new ClientBootstrap(new NioClientSocketChannelFactory(
                Executors.newCachedThreadPool(),
                Executors.newCachedThreadPool()));

                /** 随后为启动器设置了ChannelPipeLineFactory
                *目的是对channel进行数据的处理与编码与解码操作
                */
                bootstrap.setPipelineFactory(new ChannelPipelineFactory() {
                public ChannelPipeline getPipeline() throws Exception {
                return Channels.pipeline(
                new ClientMessageDecoder(),
                new ClientMessageEncoder(),
                channelUpstreamHandler);
                }
                });
                }

                /* 利用synchronized关键字声明连接方法 并获取连接后的类SocketChannel对象*/
                private synchronized void syncConnection(final String cimServerHost,final int cimServerPort) {
                try {
                if(isConnected()){
                return ;
                }
                channel  = bootstrap.connect(new InetSocketAddress(cimServerHost, cimServerPort)).getChannel(); //这里的IP和端口，根据自己情况修改
                } catch (Exception e) {
                Intent intent = new Intent();
                intent.setAction(ACTION_CONNECTION_FAILED);
                intent.putExtra(&quot;exception&quot;, e);
                context.sendBroadcast(intent);
                System.out.println(&quot;******************CIM连接服务器失败  &quot;+cimServerHost+&quot;:&quot;+cimServerPort);
                }
                }

                /* 外部可以调用的连接方法 */
                public  void connect(final String cimServerHost, final int cimServerPort) {
                /* 首先判断网络连接是否可用 */
                if (!netWorkAvailable(context)) {
                Intent intent = new Intent();
                intent.setAction(ACTION_CONNECTION_FAILED);
                intent.putExtra(&quot;exception&quot;, new NetWorkDisableException());
                context.sendBroadcast(intent);
                return;
                }
                /** 往线程池中提交任务，并捕捉返回的结果
                *也就实质上上方的syncConnection()方法是在子线程中执行的。
                *并且判断线程执行的结果，如果没有连接成功则继续调用本身继续连接。
                */
                Future&amp;lt;?&amp;gt; future = executor.submit(new Runnable() {
                @Override
                public void run() {
                syncConnection(cimServerHost, cimServerPort);
                }
                });
                try {
                if(future.get()!=null){
                connect(cimServerHost,cimServerPort);
                }
                } catch (Exception e) {
                connect(cimServerHost,cimServerPort);
                e.printStackTrace();
                }
                }

                /* 下面是比较重要的Handler也就是在这处理Channel的各种事件 */
                SimpleChannelUpstreamHandler channelUpstreamHandler = new SimpleChannelUpstreamHandler() {

                @Override
                public void channelConnected( ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {
                System.out.println(&quot;******************CIM连接服务器成功:&quot;+ctx.getChannel().getLocalAddress());
                Intent intent = new Intent();
                intent.setAction(ACTION_CONNECTION_SUCCESS);
                context.sendBroadcast(intent);
                }

                @Override
                public void channelClosed(ChannelHandlerContext ctx, ChannelStateEvent event) throws Exception {
                System.out.println(&quot;******************CIM与服务器断开连接:&quot;+ctx.getChannel().getLocalAddress());
                if(channel.getId()==ctx.getChannel().getId()){
                Intent intent = new Intent();
                intent.setAction(ACTION_CONNECTION_CLOSED);
                context.sendBroadcast(intent);
                }
                }

                @Override
                public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e)
                throws Exception {
                Intent intent = new Intent();
                intent.setAction(ACTION_UNCAUGHT_EXCEPTION);
                intent.putExtra(&quot;exception&quot;, e.getCause());
                context.sendBroadcast(intent);
                }

                @Override
                public void messageReceived(ChannelHandlerContext ctx, MessageEvent event)throws Exception {
                if (event.getMessage() instanceof Message) {
                Intent intent = new Intent();
                intent.setAction(ACTION_MESSAGE_RECEIVED);
                intent.putExtra(&quot;message&quot;, (Message) event.getMessage());
                context.sendBroadcast(intent);
                }
                if (event.getMessage() instanceof ReplyBody) {
                Intent intent = new Intent();
                intent.setAction(ACTION_REPLY_RECEIVED);
                intent.putExtra(&quot;replyBody&quot;, (ReplyBody) event.getMessage());
                context.sendBroadcast(intent);
                }
                }

                @Override
                public void writeComplete(ChannelHandlerContext ctx, WriteCompletionEvent event) throws Exception {
                Intent intent = new Intent();
                intent.setAction(ACTION_SENT_SUCCESS);
                //intent.putExtra(&quot;sentBody&quot;, null);
                context.sendBroadcast(intent);
                }
                };

                /** 接下来是发送数据的方法 同样的也是送给线程池去执行发送操作
                *值得注意的是Channel无论是发送还是接受，所得到的对象均为ChannelBuffer
                *ChannelBuffer可以理解为类似ByteBuffer的缓冲字节管理对象
                *我们在接受数据与发送数据的时候均需要把数据放入或从ChannelBuffer中取出
                *进而转化为我们想要的数据
                */
                public void send(final SentBody body) {
                executor.execute(new Runnable() {
                @Override
                public void run() {
                android.os.Message msg = new android.os.Message();
                msg.getData().putSerializable(&quot;body&quot;, body);
                if(channel!=null &amp;amp;&amp;amp; channel.isConnected()){
                boolean  isDone = channel.write(body).awaitUninterruptibly(5000);
                if (!isDone) {
                Intent intent = new Intent();
                intent.setAction(ACTION_SENT_FAILED);
                intent.putExtra(&quot;exception&quot;, new WriteToClosedSessionException());
                intent.putExtra(&quot;sentBody&quot;, body);
                context.sendBroadcast(intent);
                }
                }else{
                Intent intent = new Intent();
                intent.setAction(ACTION_SENT_FAILED);
                intent.putExtra(&quot;exception&quot;, new CIMSessionDisableException());
                intent.putExtra(&quot;sentBody&quot;, body);
                context.sendBroadcast(intent);
                }
                }
                });
                }
                }
                &lt;/code&gt;&lt;/pre&gt;

                &lt;p&gt;以上就是Netty在Android项目中使用的主要代码，具体的代码可以到文章开头的连接中去寻找原作者的Android IM 项目源码，也值得我们去学习与分析。&lt;/p&gt;

                &lt;p&gt;而关于Netty中比较重要的几个概念就是&lt;strong&gt;Boss， Worker， PipeLine，ChannelBuffer&lt;/strong&gt;&lt;/p&gt;

                &lt;ul&gt;
                &lt;li&gt;关于Boss, Worker的请查看&lt;a href=&quot;http://blog.163.com/linfenliang@126/blog/static/127857195201210744448686/?suggestedreading&quot;&gt;Netty多线程处理机制  &lt;/a&gt;这篇博文的介绍&lt;/li&gt;
                &lt;li&gt;关于PipeLine可以单纯的理解为数据从接受到抓化为你想要的数据，或者从发送的原始对象抓化为相应的数据帧的一个封装与解封装的一个过程，发送的数据会通过一层一层的Encode去发送或者是包装，相应的接收到的数据会一层一层的Decode来转化与解析。&lt;/li&gt;
                &lt;li&gt;ChannelBuffer是Channel发送数据与接收数据的原始对象，当你从handler的Receiver接口中读取到MessageEvent独享的时候， 如果没有额外的Decode那么返回的就是原始的ChannelBuffer对象&lt;/li&gt;
                &lt;/ul&gt;</column>
            <column name="image">NULL</column>
            <column name="featured">0</column>
            <column name="page">0</column>
            <column name="status">published</column>
            <column name="language">en_US</column>
            <column name="meta_title">NULL</column>
            <column name="meta_description">NULL</column>
            <column name="author_id">1</column>
            <column name="created_at">2015-05-05 10:57:38</column>
            <column name="created_by">1</column>
            <column name="updated_at">2015-05-05 14:32:36</column>
            <column name="updated_by">1</column>
            <column name="published_at">2015-05-05 10:58:59</column>
            <column name="published_by">1</column>
        </table>
        <table name="posts">
            <column name="id">28</column>
            <column name="uuid">0cfd3ced-d6be-4b65-902c-0e085c7402d6</column>
            <column name="title">Android 中 Service 的不同运行方式以及如何前台运行和自动恢复</column>
            <column name="slug">android-zhong-service-de-bu-tong-yun-xing-fang-shi-yi-ji-ru-he-qian-tai-yun-xing-he-zi-dong-hui-fu</column>
            <column name="markdown">- 1 setTextColor(getResources().getColorStateList(R.color.redeemlist_item_color))
                用于在代码里面设置可以通过Selector选择的文字颜色

                - 2 Resources.Theme theme = this.getTheme();
                TypedArray typedArray = theme.obtainStyledAttributes(new int[]{android.R.attr.colorPrimary});
                drawerLayout.setStatusBarBackground(typedArray.getResourceId(0, 0));用于读取Style中的xml配置

                - 3 如果要定义一个文字颜色的Selector需要通过 state 与 **android:color** 的方式来实现 而并非其他Selecot中的drawable 或者 用 &lt;item&gt; ... &lt;/item&gt; 中间添加其他的shape  (未确认是否能直接包裹color来实现)

                - 4 即使开启了远程Service 依然不能直接在主线程中访问网络 [SOF上的解答](http://stackoverflow.com/questions/14964819/android-what-is-main-thread-in-remote-service-network-operations-in-service)

                - 5 ListView的触摸更换颜色可以通过为其指定Selector来实现， 但是如果要保存选中状态必须通过判断并更新ListView来实现。</column>
            <column name="html">&lt;ul&gt;
                &lt;li&gt;&lt;p&gt;1 setTextColor(getResources().getColorStateList(R.color.redeemlist&lt;em&gt;item&lt;/em&gt;color))
                用于在代码里面设置可以通过Selector选择的文字颜色&lt;/p&gt;&lt;/li&gt;
                &lt;li&gt;&lt;p&gt;2 Resources.Theme theme = this.getTheme();
                TypedArray typedArray = theme.obtainStyledAttributes(new int[]{android.R.attr.colorPrimary});
                drawerLayout.setStatusBarBackground(typedArray.getResourceId(0, 0));用于读取Style中的xml配置&lt;/p&gt;&lt;/li&gt;
                &lt;li&gt;&lt;p&gt;3 如果要定义一个文字颜色的Selector需要通过 state 与 &lt;strong&gt;android:color&lt;/strong&gt; 的方式来实现 而并非其他Selecot中的drawable 或者 用 &lt;item&gt; ... &lt;/item&gt; 中间添加其他的shape  (未确认是否能直接包裹color来实现)&lt;/p&gt;&lt;/li&gt;
                &lt;li&gt;&lt;p&gt;4 即使开启了远程Service 依然不能直接在主线程中访问网络 &lt;a href=&quot;http://stackoverflow.com/questions/14964819/android-what-is-main-thread-in-remote-service-network-operations-in-service&quot;&gt;SOF上的解答&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
                &lt;li&gt;&lt;p&gt;5 ListView的触摸更换颜色可以通过为其指定Selector来实现， 但是如果要保存选中状态必须通过判断并更新ListView来实现。&lt;/p&gt;&lt;/li&gt;
                &lt;/ul&gt;</column>
            <column name="image">NULL</column>
            <column name="featured">0</column>
            <column name="page">0</column>
            <column name="status">published</column>
            <column name="language">en_US</column>
            <column name="meta_title">NULL</column>
            <column name="meta_description">NULL</column>
            <column name="author_id">1</column>
            <column name="created_at">2015-05-05 11:15:45</column>
            <column name="created_by">1</column>
            <column name="updated_at">2015-05-13 17:00:07</column>
            <column name="updated_by">1</column>
            <column name="published_at">2015-05-13 17:00:07</column>
            <column name="published_by">1</column>
        </table>
        <table name="posts">
            <column name="id">29</column>
            <column name="uuid">c129c0b6-7f96-496c-bfa5-b7b1221c3cf1</column>
            <column name="title">在手机端实现Http服务器并提供简单的控制功能 （一）</column>
            <column name="slug">zai-shou-ji-duan-shi-xian-httpfu-wu-qi-bing-ti-gong-jian-dan-de-kong-zhi-gong-neng</column>
            <column name="markdown">近几日在看有关RTSP流媒体播放相关的资料，有幸在Github上看到了[Spydroid](https://github.com/fyhertz/spydroid-ipcamera)这个项目，其中便用到了Socket做本地Http服务器的功能，于是就借此小小的研究了一番。

                &gt;需要记住的知识点

                - **Http**连接基础知识，Http基本协议
                - **Android AIDL**通信(其实只是为了方便调用远程Service)
                - **Socket**基础知识

                &gt;HTTP与Socket的区别于联系

                首先 Socket是一种连接方式，而不是协议(TCP/UDP)，而我们可以为Socket来制定不同的传输协议。

                而HTTP协议则是建立在TCP基础之上的一种协议，可以认为他对TCP进行了高级的包装。

                其实我对这方面也不是很能讲清楚其中的细枝末节，详细的信息还请google来帮助你更好的理解，总之我们需要知道如果我们指定Socket采用TCP协议来连接，我们的Socket就等同于一个TCP连接了~。

                &gt;HTTP的基本情况

                首先学过网络基础的同学都应该知道TCP的大概报文的格式，那我们来看看HTTP协议请求时的报文格式：

                ![HTTP报文格式](http://img0.tuicool.com/IBZ3ee.jpg)

                可以看出，HTTP的请求协议通常就是发送一串字符串给服务器，服务器通过约定好的格式去解析这串字符，便可以分析出这次HTTP请求的URL，方法，以及头部携带的种种信息。

                下面我们通过Socket来接收一次HTTP请求，看看到底我们“服务端”收到了什么内容。

                &gt;采用Socket来接收HTTP请求

                同样的我们在Activity中开启子线程去运行一个ServerSocket，当ServerSocket accpet 到连接请求的时候开启新的线程去处理接收到的信息并打印出来。

                ![](http://i1.tietuku.com/e244f7afc984fedf.png)

                - 其中第一个红色方框内的内容是HTTP请求的第一行字符信息，我们与上一张图的请求报文格式对比发现是一致的:


                &lt;table&gt;
                &lt;tr&gt;&lt;td&gt; GET &lt;/td&gt;&lt;td&gt; / &lt;/td&gt;&lt;td&gt; HTTP/1.1 &lt;/td&gt;&lt;/tr&gt;
                &lt;tr&gt;&lt;td&gt; 请求方法 &lt;/td&gt;&lt;td&gt; 请求URL  &lt;/td&gt;&lt;td&gt; HTTP版本 &lt;/td&gt;&lt;/tr&gt;
                &lt;/table&gt;

                看！是不是一致！

                随后我们看第二部分，也就是上图中的请求头部，该头部是可变长度的，每一行用一个回车符与换行符隔开，每一行的键值对用**:**隔开，一直到一个空行来结束请求头部。

                最后就是请求的数据部分啦。

                知道了这部分内容我们是不是已经可以做一个简单的HTTP服务器了？

                当然还不够，我们还不知道HTTP返回的报文格式！

                &gt;HTTP返回的报文格式

                HTTP的响应格式与请求格式也是类似的：

                ![](http://img0.tuicool.com/AviyMb.jpg)

                那我们就用字符串来拼接一个HTTP返回的结果。

                - 首先第一行  **版本**   **状态码** **原因短语**

                - 版本简单 我们填上 &quot;HTTP/1.1&quot;。
                - 状态码这一块可以去查询相关的比我们常常见到的404等等，这块我们返回200表示请求被正常接收。 &quot;HTTP/1.1 200&quot;
                - 状态描述 我们返回一个OK表示没问题 &quot;HTTP/1.1 200 OK&quot;


                这样我们的返回格式的第一行也凑好了。

                往下看与请求格式相对应的头部，也是同样的格式，这个时候我们简单指定一下返回的内容的类型吧:
                &quot;Content-Type:text/html;charset=utf-8&quot;

                再下来我们再返回一个空行。

                接下来就是返回的主体内容了，我们返回一个&quot;HelloWorld&quot;

                此时我们通过任意浏览器访问我们在手机上监听的端口，即可在浏览器内看到返回的内容，即&quot;HelloWolrd&quot;这几个字符串。

                &gt;通过判断请求的URL实现简单的路由功能

                这样一个简单的HTTP服务器就在我们的手机上搭设好了，但是这跟没任何卵用啊，所以我们需要针对不同的请求内容来返回不同的信息，也就是**交互**。

                有两种方式我们可以来接收到请求的不同信息：

                - 1 就是通过判断URL的方式，也是最常用的方式，因为这样方便我们将URL的路径与本地的文件路径相结合，很方便的方式。
                - 2 就是将请求的具体信息包含在文件头内部，或者采用GET/POST的方式提交到我们的服务器端，服务器端通过解析再进行进一步的处理，

                不过为了简单起见我们先搭设一个简单的路由，通过判断请求的URL的不同来返回不同的处理结果。

                =======================神奇的分割线==========================

                那我们首先就要通过解析请求的字符串来取出其中URL的这部分内容了，首先我们通过JAVA的取子字符串方法取出两个空格间的内容，也就是URL。

                我们先回头看上面的图片，当我们直接通过IP+PORT形式通过HTTP协议请求改地址时，我们得到的URL是一个**/**，在UNIX（UNIX-LIKE）系统中这个符号通常表示**根目录**。（扯远啦）

                随后我们就开始可以对其进行解析了，通过我们定义的格式，我们甚至可以将其映射到我们的SD卡文件路径中去！

                这样岂不是可以让电脑通过浏览器直接访问手机的内容了？

                其实这个功能很早很早很早。。。之前就有了，目前的AirDroid便是一款基于该技术的很好用的WEB管理Android的软件，尤其是在MAC上使用极其方便，而且新版本还实现了屏幕试试预览与控制，可见其的强大之处啦！


                话不多说，我们先加两个不同的路径上去来实现两个不同的功能吧！

                - 实现查看SD内的文件目录。
                - 实现查看已经安装的App。

            </column>
            <column name="html">&lt;p&gt;近几日在看有关RTSP流媒体播放相关的资料，有幸在Github上看到了&lt;a href=&quot;https://github.com/fyhertz/spydroid-ipcamera&quot;&gt;Spydroid&lt;/a&gt;这个项目，其中便用到了Socket做本地Http服务器的功能，于是就借此小小的研究了一番。&lt;/p&gt;

                &lt;blockquote&gt;
                &lt;p&gt;需要记住的知识点&lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;ul&gt;
                &lt;li&gt;&lt;strong&gt;Http&lt;/strong&gt;连接基础知识，Http基本协议&lt;/li&gt;
                &lt;li&gt;&lt;strong&gt;Android AIDL&lt;/strong&gt;通信(其实只是为了方便调用远程Service)&lt;/li&gt;
                &lt;li&gt;&lt;strong&gt;Socket&lt;/strong&gt;基础知识&lt;/li&gt;
                &lt;/ul&gt;

                &lt;blockquote&gt;
                &lt;p&gt;HTTP与Socket的区别于联系&lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;p&gt;首先 Socket是一种连接方式，而不是协议(TCP/UDP)，而我们可以为Socket来制定不同的传输协议。&lt;/p&gt;

                &lt;p&gt;而HTTP协议则是建立在TCP基础之上的一种协议，可以认为他对TCP进行了高级的包装。&lt;/p&gt;

                &lt;p&gt;其实我对这方面也不是很能讲清楚其中的细枝末节，详细的信息还请google来帮助你更好的理解，总之我们需要知道如果我们指定Socket采用TCP协议来连接，我们的Socket就等同于一个TCP连接了~。&lt;/p&gt;

                &lt;blockquote&gt;
                &lt;p&gt;HTTP的基本情况&lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;p&gt;首先学过网络基础的同学都应该知道TCP的大概报文的格式，那我们来看看HTTP协议请求时的报文格式：&lt;/p&gt;

                &lt;p&gt;&lt;img src=&quot;http://img0.tuicool.com/IBZ3ee.jpg&quot; alt=&quot;HTTP报文格式&quot; /&gt;&lt;/p&gt;

                &lt;p&gt;可以看出，HTTP的请求协议通常就是发送一串字符串给服务器，服务器通过约定好的格式去解析这串字符，便可以分析出这次HTTP请求的URL，方法，以及头部携带的种种信息。&lt;/p&gt;

                &lt;p&gt;下面我们通过Socket来接收一次HTTP请求，看看到底我们“服务端”收到了什么内容。&lt;/p&gt;

                &lt;blockquote&gt;
                &lt;p&gt;采用Socket来接收HTTP请求&lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;p&gt;同样的我们在Activity中开启子线程去运行一个ServerSocket，当ServerSocket accpet 到连接请求的时候开启新的线程去处理接收到的信息并打印出来。&lt;/p&gt;

                &lt;p&gt;&lt;img src=&quot;http://i1.tietuku.com/e244f7afc984fedf.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

                &lt;ul&gt;
                &lt;li&gt;其中第一个红色方框内的内容是HTTP请求的第一行字符信息，我们与上一张图的请求报文格式对比发现是一致的:&lt;/li&gt;
                &lt;/ul&gt;

                &lt;table&gt;
                &lt;tr&gt;&lt;td&gt; GET &lt;/td&gt;&lt;td&gt; / &lt;/td&gt;&lt;td&gt; HTTP/1.1 &lt;/td&gt;&lt;/tr&gt;
                &lt;tr&gt;&lt;td&gt; 请求方法 &lt;/td&gt;&lt;td&gt; 请求URL  &lt;/td&gt;&lt;td&gt; HTTP版本 &lt;/td&gt;&lt;/tr&gt;
                &lt;/table&gt;

                &lt;p&gt;看！是不是一致！&lt;/p&gt;

                &lt;p&gt;随后我们看第二部分，也就是上图中的请求头部，该头部是可变长度的，每一行用一个回车符与换行符隔开，每一行的键值对用&lt;strong&gt;:&lt;/strong&gt;隔开，一直到一个空行来结束请求头部。&lt;/p&gt;

                &lt;p&gt;最后就是请求的数据部分啦。&lt;/p&gt;

                &lt;p&gt;知道了这部分内容我们是不是已经可以做一个简单的HTTP服务器了？&lt;/p&gt;

                &lt;p&gt;当然还不够，我们还不知道HTTP返回的报文格式！&lt;/p&gt;

                &lt;blockquote&gt;
                &lt;p&gt;HTTP返回的报文格式&lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;p&gt;HTTP的响应格式与请求格式也是类似的：&lt;/p&gt;

                &lt;p&gt;&lt;img src=&quot;http://img0.tuicool.com/AviyMb.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

                &lt;p&gt;那我们就用字符串来拼接一个HTTP返回的结果。&lt;/p&gt;

                &lt;ul&gt;
                &lt;li&gt;&lt;p&gt;首先第一行  &lt;strong&gt;版本&lt;/strong&gt;   &lt;strong&gt;状态码&lt;/strong&gt; &lt;strong&gt;原因短语&lt;/strong&gt;&lt;/p&gt;

                &lt;ul&gt;&lt;li&gt;版本简单 我们填上 &quot;HTTP/1.1&quot;。&lt;/li&gt;
                &lt;li&gt;状态码这一块可以去查询相关的比我们常常见到的404等等，这块我们返回200表示请求被正常接收。 &quot;HTTP/1.1 200&quot;&lt;/li&gt;
                &lt;li&gt;状态描述 我们返回一个OK表示没问题 &quot;HTTP/1.1 200 OK&quot;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
                &lt;/ul&gt;

                &lt;p&gt;这样我们的返回格式的第一行也凑好了。&lt;/p&gt;

                &lt;p&gt;往下看与请求格式相对应的头部，也是同样的格式，这个时候我们简单指定一下返回的内容的类型吧:
                &quot;Content-Type:text/html;charset=utf-8&quot;&lt;/p&gt;

                &lt;p&gt;再下来我们再返回一个空行。&lt;/p&gt;

                &lt;p&gt;接下来就是返回的主体内容了，我们返回一个&quot;HelloWorld&quot;&lt;/p&gt;

                &lt;p&gt;此时我们通过任意浏览器访问我们在手机上监听的端口，即可在浏览器内看到返回的内容，即&quot;HelloWolrd&quot;这几个字符串。&lt;/p&gt;

                &lt;blockquote&gt;
                &lt;p&gt;通过判断请求的URL实现简单的路由功能&lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;p&gt;这样一个简单的HTTP服务器就在我们的手机上搭设好了，但是这跟没任何卵用啊，所以我们需要针对不同的请求内容来返回不同的信息，也就是&lt;strong&gt;交互&lt;/strong&gt;。&lt;/p&gt;

                &lt;p&gt;有两种方式我们可以来接收到请求的不同信息：&lt;/p&gt;

                &lt;ul&gt;
                &lt;li&gt;1 就是通过判断URL的方式，也是最常用的方式，因为这样方便我们将URL的路径与本地的文件路径相结合，很方便的方式。&lt;/li&gt;
                &lt;li&gt;2 就是将请求的具体信息包含在文件头内部，或者采用GET/POST的方式提交到我们的服务器端，服务器端通过解析再进行进一步的处理，&lt;/li&gt;
                &lt;/ul&gt;

                &lt;p&gt;不过为了简单起见我们先搭设一个简单的路由，通过判断请求的URL的不同来返回不同的处理结果。&lt;/p&gt;

                &lt;p&gt;====================&lt;mark&gt;=神奇的分割线&lt;/mark&gt;========================&lt;/p&gt;

                &lt;p&gt;那我们首先就要通过解析请求的字符串来取出其中URL的这部分内容了，首先我们通过JAVA的取子字符串方法取出两个空格间的内容，也就是URL。&lt;/p&gt;

                &lt;p&gt;我们先回头看上面的图片，当我们直接通过IP+PORT形式通过HTTP协议请求改地址时，我们得到的URL是一个&lt;strong&gt;/&lt;/strong&gt;，在UNIX（UNIX-LIKE）系统中这个符号通常表示&lt;strong&gt;根目录&lt;/strong&gt;。（扯远啦）&lt;/p&gt;

                &lt;p&gt;随后我们就开始可以对其进行解析了，通过我们定义的格式，我们甚至可以将其映射到我们的SD卡文件路径中去！&lt;/p&gt;

                &lt;p&gt;这样岂不是可以让电脑通过浏览器直接访问手机的内容了？&lt;/p&gt;

                &lt;p&gt;其实这个功能很早很早很早。。。之前就有了，目前的AirDroid便是一款基于该技术的很好用的WEB管理Android的软件，尤其是在MAC上使用极其方便，而且新版本还实现了屏幕试试预览与控制，可见其的强大之处啦！&lt;/p&gt;

                &lt;p&gt;话不多说，我们先加两个不同的路径上去来实现两个不同的功能吧！&lt;/p&gt;

                &lt;ul&gt;
                &lt;li&gt;实现查看SD内的文件目录。&lt;/li&gt;
                &lt;li&gt;实现查看已经安装的App。&lt;/li&gt;
                &lt;/ul&gt;</column>
            <column name="image">NULL</column>
            <column name="featured">0</column>
            <column name="page">0</column>
            <column name="status">published</column>
            <column name="language">en_US</column>
            <column name="meta_title">NULL</column>
            <column name="meta_description">NULL</column>
            <column name="author_id">1</column>
            <column name="created_at">2015-05-15 11:04:52</column>
            <column name="created_by">1</column>
            <column name="updated_at">2015-05-22 16:42:12</column>
            <column name="updated_by">1</column>
            <column name="published_at">2015-05-15 11:05:06</column>
            <column name="published_by">1</column>
        </table>
        <table name="posts">
            <column name="id">30</column>
            <column name="uuid">157cae3c-ac0a-406b-8ba6-58ac0805f40b</column>
            <column name="title">Android 实现波纹动画效果</column>
            <column name="slug">android-shi-xian-bo-wen-dong-hua-xiao-guo</column>
            <column name="markdown"></column>
            <column name="html"></column>
            <column name="image">NULL</column>
            <column name="featured">0</column>
            <column name="page">0</column>
            <column name="status">draft</column>
            <column name="language">en_US</column>
            <column name="meta_title">NULL</column>
            <column name="meta_description">NULL</column>
            <column name="author_id">1</column>
            <column name="created_at">2015-05-22 13:28:13</column>
            <column name="created_by">1</column>
            <column name="updated_at">2015-05-22 16:46:31</column>
            <column name="updated_by">1</column>
            <column name="published_at">NULL</column>
            <column name="published_by">NULL</column>
        </table>
        <table name="posts">
            <column name="id">31</column>
            <column name="uuid">10e0f0ce-052c-4029-a3f0-984f64cf95f8</column>
            <column name="title">Ubuntu 上搭建Nodejs环境</column>
            <column name="slug">ubuntu-shang-da-jian-nodejshuan-jing</column>
            <column name="markdown"></column>
            <column name="html"></column>
            <column name="image">NULL</column>
            <column name="featured">0</column>
            <column name="page">0</column>
            <column name="status">published</column>
            <column name="language">en_US</column>
            <column name="meta_title">NULL</column>
            <column name="meta_description">NULL</column>
            <column name="author_id">1</column>
            <column name="created_at">2015-05-27 12:36:16</column>
            <column name="created_by">1</column>
            <column name="updated_at">2015-05-27 12:36:16</column>
            <column name="updated_by">1</column>
            <column name="published_at">2015-05-27 12:36:16</column>
            <column name="published_by">1</column>
        </table>
        <table name="posts">
            <column name="id">32</column>
            <column name="uuid">b76caa40-7223-4a74-8a6f-614473bdf756</column>
            <column name="title">Express中使用hbs模板</column>
            <column name="slug">expresszhong-shi-yong-hbsmo-ban</column>
            <column name="markdown"></column>
            <column name="html"></column>
            <column name="image">NULL</column>
            <column name="featured">0</column>
            <column name="page">0</column>
            <column name="status">published</column>
            <column name="language">en_US</column>
            <column name="meta_title">NULL</column>
            <column name="meta_description">NULL</column>
            <column name="author_id">1</column>
            <column name="created_at">2015-06-02 13:36:22</column>
            <column name="created_by">1</column>
            <column name="updated_at">2015-06-02 13:36:22</column>
            <column name="updated_by">1</column>
            <column name="published_at">2015-06-02 13:36:22</column>
            <column name="published_by">1</column>
        </table>
        <table name="posts">
            <column name="id">33</column>
            <column name="uuid">6ed14d69-ea2e-4c0a-9d54-c6e6ab160421</column>
            <column name="title">float block inline-block 区别小记</column>
            <column name="slug">float-block-inline-block-qu-bie-xiao-ji</column>
            <column name="markdown"></column>
            <column name="html"></column>
            <column name="image">NULL</column>
            <column name="featured">0</column>
            <column name="page">0</column>
            <column name="status">published</column>
            <column name="language">en_US</column>
            <column name="meta_title">NULL</column>
            <column name="meta_description">NULL</column>
            <column name="author_id">1</column>
            <column name="created_at">2015-06-04 08:50:28</column>
            <column name="created_by">1</column>
            <column name="updated_at">2015-06-04 08:50:47</column>
            <column name="updated_by">1</column>
            <column name="published_at">2015-06-04 08:50:28</column>
            <column name="published_by">1</column>
        </table>
        <table name="posts">
            <column name="id">34</column>
            <column name="uuid">72df0376-f882-45c1-8475-af5b2bf3b530</column>
            <column name="title">MongoDB Mongoose AngularJS简介</column>
            <column name="slug">mongodb-mongoose-angularjsjian-jie</column>
            <column name="markdown"></column>
            <column name="html"></column>
            <column name="image">NULL</column>
            <column name="featured">0</column>
            <column name="page">0</column>
            <column name="status">published</column>
            <column name="language">en_US</column>
            <column name="meta_title">NULL</column>
            <column name="meta_description">NULL</column>
            <column name="author_id">1</column>
            <column name="created_at">2015-06-09 08:27:07</column>
            <column name="created_by">1</column>
            <column name="updated_at">2015-06-09 08:27:07</column>
            <column name="updated_by">1</column>
            <column name="published_at">2015-06-09 08:27:07</column>
            <column name="published_by">1</column>
        </table>
        <table name="posts">
            <column name="id">35</column>
            <column name="uuid">31e7feba-964f-43c9-a2da-a0c33c956f33</column>
            <column name="title">NodeJS 与微信企业号交互</column>
            <column name="slug">nodejs-yu-wei-xin-qi-ye-hao-jiao-hu</column>
            <column name="markdown">- 首先注册微信企业号 [戳这里](https://qy.weixin.qq.com)
                - 选择微信企业号，并根据你需要的类型注册不同的类型，这里我选择了团体类型，基本上不需要怎么审核，但是起始的上线仅有50人。
                - 在输入一堆信息之后，注册成功，立即来到其开发者[文档](http://qydev.weixin.qq.com/wiki/index.php?title=%E9%A6%96%E9%A1%B5)这里,开始开发咯！

                &gt;获取TOKEN

                文档告诉我们，在一切服务器之前我们必须要先从腾讯哪里获取token


                --------------------
                获取AccessToken

                AccessToken是企业号的全局唯一票据，调用接口时需携带AccessToken。

                AccessToken需要用CorpID和Secret来换取，不同的Secret会返回不同的AccessToken。正常情况下AccessToken有效期为7200秒，有效期内重复获取返回相同结果；有效期内有接口交互（包括获取AccessToken的接口），会自动续期。

                请求说明
                Https请求方式: GET

                https://qyapi.weixin.qq.com/cgi-bin/gettoken?corpid=id&amp;corpsecret=secrect

                参数说明
                参数	必须	说明
                corpid	是	企业Id
                corpsecret	是	管理组的凭证密钥
                权限说明
                每个secret代表了对应用、通讯录、接口的不同权限；不同的管理组拥有不同的secret。

                ----------------

                那么在nodejs中我们就需要通过核心模块中的 https 进行get请求并对请求的结果进行解析

                ```
                var https = require('https'); // https 模块
                var bl = require('bl');

                https.get('https://qyapi.weixin.qq.com/cgi-bin/gettoken?corpid='+setting.corpid+'&amp;corpsecret='+setting.corpsecret, function(response) {
                response.setEncoding('utf-8');
                response.pipe(bl(function(err, data){
                if (err) {
                callback(err);
                } else {
                /* 转化json */
                var json = JSON.parse(data.toString());
                if (json.errcode) {
                console.log(json.errmsg);
                /* 提示获取失败 */
                callback(null, null);
                } else {
                console.log(json.access_token);
                callback(null, json.access_token);
                }
                }
                }));
                });

                ```

                在获取了token之后，我们就可以进行下一步的操作了，注意根据文档，token的过期时间为7200秒，也就是2小时，而且在每次调用后都会延长。

                &gt;发送最简单的text消息

                根据文档，我们需要以POST的方式，通过https协议提交需要发送的数据给服务器，同样的我们还是调用https模块来实现我们要的功能。

                但是根据nodejs的[文档](https://nodejs.org/api/https.html#https_https_request_options_callback)，并没有现成的https.post()方法，我们只能采用https.request()方法，文档也是比较详细，但是由于我自己对https以及post的了解还是停留在大学课本的水准上，并没有什么实际的经验，在这点上也是费了好长的时间，话不多说，先看代码:

                - 首选我们根据微信的文档来拼装我们的Json格式的数据:

                ```
                var data = JSON.stringify({
                &quot;touser&quot;: &quot;admin&quot;,  // 发送指定人的ID，注意ID是管理员指定并邀请相应的微信用户关注 或者发给分组 或是 @all 全部人员 我们也可以采用 toparty totag 等字段来制定发送的对象
                &quot;msgtype&quot;: &quot;text&quot;,
                &quot;agentid&quot;: &quot;0&quot;,
                &quot;text&quot;: {
                &quot;content&quot;: &quot;呵呵答&quot;
                },
                &quot;safe&quot;:&quot;0&quot;
                });

                ```

                - 接下来我们来组装post数据所需要的option内容

                ```
                var options = {
                hostname: 'qyapi.weixin.qq.com',  //微信文档中的让我们访问地址的域名
                path: '/cgi-bin/message/send?access_token=' + token,
                method: 'POST', //方式指定为POST
                headers: {
                'Content-Type' : 'application/json;charset=UTF-8',
                'Content-Length': data.length // 此处是我们发送的json数据的长度 必须指定这否则服务器不知道读到哪里算是结束  就会读取数据错误而不能正确处理
                }
                ```

                - 最后通过调用https.request(options, callback);方法获得一个请求对象 request, 并调用request对象的write()方法，这点与Nodejs中的 res, req 都是类似的流对象，所以方法名也基本上一致。

                - 发送完毕后记得调用 request.end()方法关闭流，否则会抛出连接超时的错误！

                &gt;实战测试

                我们在浏览器调用指定的url地址，发现的确能够访问，但是写死的发送内容显然是没有任何意义的，所以我们通过读取get请求的参数来自动的修改发送内容，于是我发送了很长很长的一串汉字，但是！神奇的地方出现了，微信告诉我: **{ errcode:40004, errmsg: &quot;empty content&quot;}**，我真是R了狗了，刚才还没事，这小小的已修改就出问题了？

                好在微信还够良心，给了我们一个在线的[调试系统](http://qydev.weixin.qq.com/debug)，我在这把我发送的json内容粘贴进去，选择发送消息....

                竟然可以发送？我去！@#！@%@#……#%这是闹哪样？

                为了检测这个问题出现在哪里，改了又改，发现如果是使用英文，那么就不会出现该问题，所以我就想是不是是文件编码的问题？其实这一块我也是云里雾里的，毕竟也是刚刚从android开发慢慢学习web应用开发，还是需要很多学习啊。但是从console.log()打印出来的发送内容上来看，不存在这个编码问题，最后经过google与国内Node论坛 [cnnode.js](https://cnodejs.org) 发现了以为前辈的[文章](https://cnodejs.org/topic/4fabf73aa016fe532302738c)，才明白到底是怎么回事。

                &gt;成功解决

                根据前辈的[代码](https://cnodejs.org/topic/4fabf73aa016fe532302738c),将读取长度的方法替换为
                **Buffer.byteLength(data, 'utf8')**

                OK 问题顺利解决！

                &gt;总结

                最近项目也比较忙，也是刚开始认真接触NodeJS，慢慢</column>
            <column name="html">&lt;ul&gt;
                &lt;li&gt;首先注册微信企业号 &lt;a href=&quot;https://qy.weixin.qq.com&quot;&gt;戳这里&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;选择微信企业号，并根据你需要的类型注册不同的类型，这里我选择了团体类型，基本上不需要怎么审核，但是起始的上线仅有50人。&lt;/li&gt;
                &lt;li&gt;在输入一堆信息之后，注册成功，立即来到其开发者&lt;a href=&quot;http://qydev.weixin.qq.com/wiki/index.php?title=%E9%A6%96%E9%A1%B5&quot;&gt;文档&lt;/a&gt;这里,开始开发咯！&lt;/li&gt;
                &lt;/ul&gt;

                &lt;blockquote&gt;
                &lt;p&gt;获取TOKEN&lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;p&gt;文档告诉我们，在一切服务器之前我们必须要先从腾讯哪里获取token&lt;/p&gt;

                &lt;hr /&gt;

                &lt;p&gt;获取AccessToken&lt;/p&gt;

                &lt;p&gt;AccessToken是企业号的全局唯一票据，调用接口时需携带AccessToken。&lt;/p&gt;

                &lt;p&gt;AccessToken需要用CorpID和Secret来换取，不同的Secret会返回不同的AccessToken。正常情况下AccessToken有效期为7200秒，有效期内重复获取返回相同结果；有效期内有接口交互（包括获取AccessToken的接口），会自动续期。&lt;/p&gt;

                &lt;p&gt;请求说明
                Https请求方式: GET&lt;/p&gt;

                &lt;p&gt;&lt;a href=&quot;https://qyapi.weixin.qq.com/cgi-bin/gettoken?corpid=id&amp;amp;corpsecret=secrect&quot;&gt;https://qyapi.weixin.qq.com/cgi-bin/gettoken?corpid=id&amp;amp;corpsecret=secrect&lt;/a&gt;&lt;/p&gt;

                &lt;p&gt;参数说明
                参数    必须  说明
                corpid    是   企业Id &lt;br /&gt;
                corpsecret    是   管理组的凭证密钥 &lt;br /&gt;
                权限说明
                每个secret代表了对应用、通讯录、接口的不同权限；不同的管理组拥有不同的secret。&lt;/p&gt;

                &lt;hr /&gt;

                &lt;p&gt;那么在nodejs中我们就需要通过核心模块中的 https 进行get请求并对请求的结果进行解析&lt;/p&gt;

                &lt;pre&gt;&lt;code&gt;var https = require('https'); // https 模块
                var bl = require('bl');

                https.get('https://qyapi.weixin.qq.com/cgi-bin/gettoken?corpid='+setting.corpid+'&amp;amp;corpsecret='+setting.corpsecret, function(response) {
                response.setEncoding('utf-8');
                response.pipe(bl(function(err, data){
                if (err) {
                callback(err);
                } else {
                /* 转化json */
                var json = JSON.parse(data.toString());
                if (json.errcode) {
                console.log(json.errmsg);
                /* 提示获取失败 */
                callback(null, null);
                } else {
                console.log(json.access_token);
                callback(null, json.access_token);
                }
                }
                }));
                });
                &lt;/code&gt;&lt;/pre&gt;

                &lt;p&gt;在获取了token之后，我们就可以进行下一步的操作了，注意根据文档，token的过期时间为7200秒，也就是2小时，而且在每次调用后都会延长。&lt;/p&gt;

                &lt;blockquote&gt;
                &lt;p&gt;发送最简单的text消息&lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;p&gt;根据文档，我们需要以POST的方式，通过https协议提交需要发送的数据给服务器，同样的我们还是调用https模块来实现我们要的功能。&lt;/p&gt;

                &lt;p&gt;但是根据nodejs的&lt;a href=&quot;https://nodejs.org/api/https.html#https_https_request_options_callback&quot;&gt;文档&lt;/a&gt;，并没有现成的https.post()方法，我们只能采用https.request()方法，文档也是比较详细，但是由于我自己对https以及post的了解还是停留在大学课本的水准上，并没有什么实际的经验，在这点上也是费了好长的时间，话不多说，先看代码:&lt;/p&gt;

                &lt;ul&gt;
                &lt;li&gt;首选我们根据微信的文档来拼装我们的Json格式的数据:&lt;/li&gt;
                &lt;/ul&gt;

                &lt;pre&gt;&lt;code&gt;var data = JSON.stringify({
                &quot;touser&quot;: &quot;admin&quot;,  // 发送指定人的ID，注意ID是管理员指定并邀请相应的微信用户关注 或者发给分组 或是 @all 全部人员 我们也可以采用 toparty totag 等字段来制定发送的对象
                &quot;msgtype&quot;: &quot;text&quot;,
                &quot;agentid&quot;: &quot;0&quot;,
                &quot;text&quot;: {
                &quot;content&quot;: &quot;呵呵答&quot;
                },
                &quot;safe&quot;:&quot;0&quot;
                });
                &lt;/code&gt;&lt;/pre&gt;

                &lt;ul&gt;
                &lt;li&gt;接下来我们来组装post数据所需要的option内容&lt;/li&gt;
                &lt;/ul&gt;

                &lt;pre&gt;&lt;code&gt;var options = {
                hostname: 'qyapi.weixin.qq.com',  //微信文档中的让我们访问地址的域名
                path: '/cgi-bin/message/send?access_token=' + token,
                method: 'POST', //方式指定为POST
                headers: {
                'Content-Type' : 'application/json;charset=UTF-8',
                'Content-Length': data.length // 此处是我们发送的json数据的长度 必须指定这否则服务器不知道读到哪里算是结束  就会读取数据错误而不能正确处理
                }
                &lt;/code&gt;&lt;/pre&gt;

                &lt;ul&gt;
                &lt;li&gt;&lt;p&gt;最后通过调用https.request(options, callback);方法获得一个请求对象 request, 并调用request对象的write()方法，这点与Nodejs中的 res, req 都是类似的流对象，所以方法名也基本上一致。&lt;/p&gt;&lt;/li&gt;
                &lt;li&gt;&lt;p&gt;发送完毕后记得调用 request.end()方法关闭流，否则会抛出连接超时的错误！&lt;/p&gt;&lt;/li&gt;
                &lt;/ul&gt;

                &lt;blockquote&gt;
                &lt;p&gt;实战测试&lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;p&gt;我们在浏览器调用指定的url地址，发现的确能够访问，但是写死的发送内容显然是没有任何意义的，所以我们通过读取get请求的参数来自动的修改发送内容，于是我发送了很长很长的一串汉字，但是！神奇的地方出现了，微信告诉我: &lt;strong&gt;{ errcode:40004, errmsg: &quot;empty content&quot;}&lt;/strong&gt;，我真是R了狗了，刚才还没事，这小小的已修改就出问题了？&lt;/p&gt;

                &lt;p&gt;好在微信还够良心，给了我们一个在线的&lt;a href=&quot;http://qydev.weixin.qq.com/debug&quot;&gt;调试系统&lt;/a&gt;，我在这把我发送的json内容粘贴进去，选择发送消息....&lt;/p&gt;

                &lt;p&gt;竟然可以发送？我去！@#！@%@#……#%这是闹哪样？&lt;/p&gt;

                &lt;p&gt;为了检测这个问题出现在哪里，改了又改，发现如果是使用英文，那么就不会出现该问题，所以我就想是不是是文件编码的问题？其实这一块我也是云里雾里的，毕竟也是刚刚从android开发慢慢学习web应用开发，还是需要很多学习啊。但是从console.log()打印出来的发送内容上来看，不存在这个编码问题，最后经过google与国内Node论坛 &lt;a href=&quot;https://cnodejs.org&quot;&gt;cnnode.js&lt;/a&gt; 发现了以为前辈的&lt;a href=&quot;https://cnodejs.org/topic/4fabf73aa016fe532302738c&quot;&gt;文章&lt;/a&gt;，才明白到底是怎么回事。&lt;/p&gt;

                &lt;blockquote&gt;
                &lt;p&gt;成功解决&lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;p&gt;根据前辈的&lt;a href=&quot;https://cnodejs.org/topic/4fabf73aa016fe532302738c&quot;&gt;代码&lt;/a&gt;,将读取长度的方法替换为 &lt;br /&gt;
                &lt;strong&gt;Buffer.byteLength(data, 'utf8')&lt;/strong&gt;&lt;/p&gt;

                &lt;p&gt;OK 问题顺利解决！&lt;/p&gt;

                &lt;blockquote&gt;
                &lt;p&gt;总结&lt;/p&gt;
                &lt;/blockquote&gt;

                &lt;p&gt;最近项目也比较忙，也是刚开始认真接触NodeJS，慢慢&lt;/p&gt;</column>
            <column name="image">NULL</column>
            <column name="featured">0</column>
            <column name="page">0</column>
            <column name="status">published</column>
            <column name="language">en_US</column>
            <column name="meta_title">NULL</column>
            <column name="meta_description">NULL</column>
            <column name="author_id">1</column>
            <column name="created_at">2015-06-11 11:00:49</column>
            <column name="created_by">1</column>
            <column name="updated_at">2015-06-11 16:50:58</column>
            <column name="updated_by">1</column>
            <column name="published_at">2015-06-11 11:00:49</column>
            <column name="published_by">1</column>
        </table>
        <table name="posts">
            <column name="id">36</column>
            <column name="uuid">d454e272-5dc0-4097-b42e-c68688b3f64b</column>
            <column name="title">新版本Bilibili Android客户端的ViewPager嵌套的效果</column>
            <column name="slug">xin-ban-ben-bilibili-androidke-hu-duan-de-viewpagerqian-tao-de-xiao-guo</column>
            <column name="markdown"></column>
            <column name="html"></column>
            <column name="image">NULL</column>
            <column name="featured">0</column>
            <column name="page">0</column>
            <column name="status">published</column>
            <column name="language">en_US</column>
            <column name="meta_title">NULL</column>
            <column name="meta_description">NULL</column>
            <column name="author_id">1</column>
            <column name="created_at">2015-06-12 09:19:46</column>
            <column name="created_by">1</column>
            <column name="updated_at">2015-06-12 09:19:46</column>
            <column name="updated_by">1</column>
            <column name="published_at">2015-06-12 09:19:46</column>
            <column name="published_by">1</column>
        </table>
        <table name="posts">
            <column name="id">37</column>
            <column name="uuid">470cdf4a-8760-48eb-a672-c0b14902003e</column>
            <column name="title">BCE 部署Node项目并连接MongoDb 与 微信企业号操作</column>
            <column name="slug">bce-bu-shu-nodexiang-mu-bing-lian-jie-mongodb-yu-wei-xin-qi-ye-hao-cao-zuo</column>
            <column name="markdown"></column>
            <column name="html"></column>
            <column name="image">NULL</column>
            <column name="featured">0</column>
            <column name="page">0</column>
            <column name="status">published</column>
            <column name="language">en_US</column>
            <column name="meta_title">NULL</column>
            <column name="meta_description">NULL</column>
            <column name="author_id">1</column>
            <column name="created_at">2015-06-19 11:06:57</column>
            <column name="created_by">1</column>
            <column name="updated_at">2015-06-19 11:06:57</column>
            <column name="updated_by">1</column>
            <column name="published_at">2015-06-19 11:06:57</column>
            <column name="published_by">1</column>
        </table>
        <table name="posts">
            <column name="id">38</column>
            <column name="uuid">16bfae61-3e36-4724-9e67-bc411bd2506b</column>
            <column name="title">近期遇到的一些奇妙BUG</column>
            <column name="slug">jin-qi-yu-dao-de-xie-qi-miao-bug</column>
            <column name="markdown">- http://blog.fancyu.me/?p=58
                - Attrubute has already been defined
                - ic_launcher duplicate file
            </column>
            <column name="html">&lt;ul&gt;
                &lt;li&gt;&lt;a href=&quot;http://blog.fancyu.me/?p=58&quot;&gt;http://blog.fancyu.me/?p=58&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;Attrubute has already been defined&lt;/li&gt;
                &lt;li&gt;ic_launcher duplicate file&lt;/li&gt;
                &lt;/ul&gt;</column>
            <column name="image">NULL</column>
            <column name="featured">0</column>
            <column name="page">0</column>
            <column name="status">published</column>
            <column name="language">en_US</column>
            <column name="meta_title">NULL</column>
            <column name="meta_description">NULL</column>
            <column name="author_id">1</column>
            <column name="created_at">2015-06-25 16:31:21</column>
            <column name="created_by">1</column>
            <column name="updated_at">2015-07-10 09:42:32</column>
            <column name="updated_by">1</column>
            <column name="published_at">2015-06-25 16:31:25</column>
            <column name="published_by">1</column>
        </table>
        <table name="posts">
            <column name="id">39</column>
            <column name="uuid">a4b46b77-e8b4-4ac6-b4b4-4e07ec95317a</column>
            <column name="title">Android JS等自动构建工具的学习笔记</column>
            <column name="slug">android-jsdeng-zi-dong-gou-jian-gong-ju-de-xue-xi-bi-ji</column>
            <column name="markdown"></column>
            <column name="html"></column>
            <column name="image">NULL</column>
            <column name="featured">0</column>
            <column name="page">0</column>
            <column name="status">published</column>
            <column name="language">en_US</column>
            <column name="meta_title">NULL</column>
            <column name="meta_description">NULL</column>
            <column name="author_id">1</column>
            <column name="created_at">2015-06-30 11:22:14</column>
            <column name="created_by">1</column>
            <column name="updated_at">2015-06-30 11:22:16</column>
            <column name="updated_by">1</column>
            <column name="published_at">2015-06-30 11:22:16</column>
            <column name="published_by">1</column>
        </table>
        <table name="posts">
            <column name="id">40</column>
            <column name="uuid">818a1fad-8201-409e-bf44-3523b06e64a7</column>
            <column name="title">Bluebird 实现 Promise</column>
            <column name="slug">bluebird-shi-xian-promise</column>
            <column name="markdown"></column>
            <column name="html"></column>
            <column name="image">NULL</column>
            <column name="featured">0</column>
            <column name="page">0</column>
            <column name="status">published</column>
            <column name="language">en_US</column>
            <column name="meta_title">NULL</column>
            <column name="meta_description">NULL</column>
            <column name="author_id">1</column>
            <column name="created_at">2015-07-06 15:21:24</column>
            <column name="created_by">1</column>
            <column name="updated_at">2015-07-06 15:21:24</column>
            <column name="updated_by">1</column>
            <column name="published_at">2015-07-06 15:21:24</column>
            <column name="published_by">1</column>
        </table>
        <table name="posts">
            <column name="id">41</column>
            <column name="uuid">5effaff7-6a74-41cb-9367-90ae9cae4e50</column>
            <column name="title">dispatchKeyEventPreIme</column>
            <column name="slug">dispatchkeyeventpreime</column>
            <column name="markdown"></column>
            <column name="html"></column>
            <column name="image">NULL</column>
            <column name="featured">0</column>
            <column name="page">0</column>
            <column name="status">published</column>
            <column name="language">en_US</column>
            <column name="meta_title">NULL</column>
            <column name="meta_description">NULL</column>
            <column name="author_id">1</column>
            <column name="created_at">2015-07-22 08:48:26</column>
            <column name="created_by">1</column>
            <column name="updated_at">2015-07-22 08:48:29</column>
            <column name="updated_by">1</column>
            <column name="published_at">2015-07-22 08:48:29</column>
            <column name="published_by">1</column>
        </table>
        <table name="posts">
            <column name="id">42</column>
            <column name="uuid">489642c7-c848-4b23-b48a-2341e28c8b9e</column>
            <column name="title">您的 Ghost 博客系统已经升级到最新版了！</column>
            <column name="slug">ghost-0-7</column>
            <column name="markdown">您的 Ghost 博客系统已经升级到最新版了！新版 Ghost 的功能有如下这些改变需要您特别关注一下！

                ## 哇，为什么一切都看上去不同了？

                历经两年开发和上万用户的反馈，我们认识到老的 Ghost 后台界面有哪些优点和不足。现在您所看到的是 Ghost 的首次后台界面大升级，着重改进易用性和稳定性。

                ![新设计](http://static.ghostchina.com/image/2/50/0a96874d2150820509ec84099a154.png)

                新的导航菜单（以前是放在页面顶部的）被放在页面左侧了，在移动设备上会更易用，并且为即将到来的更多新特性留出了足够的扩展空间！

                ## 文章搜索

                经过和很多用户的交流，我们发现用户在查找文章时很不方便，尤其是文章太多的情况。因此我们新增了一项搜索功能，让查找文章变得更轻松，避免了无休止的拖拽滚动条。赶紧试一试吧！

                ![文章搜索](http://static.ghostchina.com/image/e/b0/17e6a1a1477b41f8116060113230a.gif)

                还有其他问题吗？ 可以进入 [论坛](http://wenda.ghostchina.com/) 和我们交流。

                当然，如果这篇草稿已经对您没用了，请尽管删除吧！</column>
            <column name="html">&lt;p&gt;您的 Ghost 博客系统已经升级到最新版了！新版 Ghost 的功能有如下这些改变需要您特别关注一下！&lt;/p&gt;

                &lt;h2 id=&quot;&quot;&gt;哇，为什么一切都看上去不同了？&lt;/h2&gt;

                &lt;p&gt;历经两年开发和上万用户的反馈，我们认识到老的 Ghost 后台界面有哪些优点和不足。现在您所看到的是 Ghost 的首次后台界面大升级，着重改进易用性和稳定性。&lt;/p&gt;

                &lt;p&gt;&lt;img src=&quot;http://static.ghostchina.com/image/2/50/0a96874d2150820509ec84099a154.png&quot; alt=&quot;新设计&quot; /&gt;&lt;/p&gt;

                &lt;p&gt;新的导航菜单（以前是放在页面顶部的）被放在页面左侧了，在移动设备上会更易用，并且为即将到来的更多新特性留出了足够的扩展空间！&lt;/p&gt;

                &lt;h2 id=&quot;&quot;&gt;文章搜索&lt;/h2&gt;

                &lt;p&gt;经过和很多用户的交流，我们发现用户在查找文章时很不方便，尤其是文章太多的情况。因此我们新增了一项搜索功能，让查找文章变得更轻松，避免了无休止的拖拽滚动条。赶紧试一试吧！&lt;/p&gt;

                &lt;p&gt;&lt;img src=&quot;http://static.ghostchina.com/image/e/b0/17e6a1a1477b41f8116060113230a.gif&quot; alt=&quot;文章搜索&quot; /&gt;&lt;/p&gt;

                &lt;p&gt;还有其他问题吗？ 可以进入 &lt;a href=&quot;http://wenda.ghostchina.com/&quot;&gt;论坛&lt;/a&gt; 和我们交流。&lt;/p&gt;

                &lt;p&gt;当然，如果这篇草稿已经对您没用了，请尽管删除吧！&lt;/p&gt;</column>
            <column name="image">NULL</column>
            <column name="featured">0</column>
            <column name="page">0</column>
            <column name="status">draft</column>
            <column name="language">zh_CN</column>
            <column name="meta_title">NULL</column>
            <column name="meta_description">NULL</column>
            <column name="author_id">1</column>
            <column name="created_at">2015-11-19 13:46:37</column>
            <column name="created_by">1</column>
            <column name="updated_at">2015-11-19 13:46:37</column>
            <column name="updated_by">1</column>
            <column name="published_at">2015-11-19 13:46:37</column>
            <column name="published_by">NULL</column>
        </table>
    </database>
</pma_xml_export>